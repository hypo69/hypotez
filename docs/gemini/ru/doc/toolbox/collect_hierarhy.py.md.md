# ИНСТРУКЦИЯ

Предоставленный ниже код - часть проекта `hypotez`. Задача: создать документацию для разработчика в формате `Markdown` для каждого входного Python-файла. 
Документация должна соответствовать следующим требованиям:

1. **Формат документации**:
   - Используй стандарт `Markdown (.md)`.
   - Каждый файл должен начинаться с заголовка и краткого описания его содержимого.

   Примеры документации: Пример загаоловка файла модуля:

        """
        Модуль для работы с ассистентом программиста
        =================================================

        Модуль содержит класс :class:`CodeAssistant`, который используется для взаимодействия с различными AI-моделями
        (например, Google Gemini и OpenAI) и выполнения задач обработки кода.

        Пример использования
        ----------------------

        >>>assistant = CodeAssistant(role='code_checker', lang='ru', model=['gemini'])
        >>>assistant.process_files()
        """

   - Для всех классов и функций используйте следующий формат комментариев:
     ```python
     class MyClass:
         """Описание назначения класса
         Inherits: 
            Если класс наследует другой - дай описание наследования

         Attributes:
            param1 (str): Описание параметров (атрибуты) класса

         Methods:
            function_1(): Описание назаначения функций/методов класса
        """
     
         def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
             """ Функция выполняет некоторое действия... <Тут Ты пишешь что именно делает функция> 
             Args:
                 param (str): Описание параметра `param`.
                 param1 (Optional[str | dict | str], optional): Описание параметра `param1`. По умолчанию `None`.

             Returns:
                 dict | None: Описание возвращаемого значения. Возвращает словарь или `None`.

             Raises:
                 SomeError: Описание ситуации, в которой возникает исключение `SomeError`.
                ...
                <Выводить тело функции НЕ НАДО. Только docstring>
             """
             def inner_function():
                """ Внутрняя функция Функция выполняет некоторое действия... <Тут Ты пишешь что именно делает функция> 
                    Args:
                        param (str): Описание параметра `param`.
                        param1 (Optional[str | dict | str], optional): Описание параметра `param1`. По умолчанию `None`.

                    Returns:
                        dict | None: Описание возвращаемого значения. Возвращает словарь или `None`.

                    Raises:
                        SomeError: Описание ситуации, в которой возникает исключение `SomeError`.

                    ...
                  
                      НЕ ВЫВОДИ КОД ФУНКЦИИ. ТОЛЬКО DOCSTR

                    """
         ```
     - Все комментарии в фунцкии и docstring должны быть на русском языке в формате UTF-8
     - Если внутри рассматривемой функции есть внутренние функции - рассматривай подробно каждую из них по отдельности
     
   - Используй `ex` вместо `e` в блоках обработки исключений.
   - Для логгирования используй `logger` из моего модуля `src.logger`. Например:
     ```python
     from src.logger import logger
     logger.info('Some information message')
     ...
     except SomeError as ex:
         logger.error('Some error message', ex, exc_info = True), где ошибка передается вторым аргументом. exc_info определает надо ли выводить служебную информацию.
    ```


    _ Если в коде используется вебдрайвер, знай как его использовать
    наследуй Driver, Chrome, Firexox, Playwright
    Далее определи так
    # Создание инстанса драйвера (пример с Chrome)
    driver = Drivewr(Chrome)
    В модулях Driver И Chrome, Firexox, Playwright уже содержатся все настройки selenium. 
    Основная комада, которая используется в коде: `driver.execute_locator(l:dict)`
    Она возвращает аначение вебэелемента по локатору.


   - Все комментарии и docstring должны быть на русском языке в формате UTF-8. Если в коде docsting на английском - сделай перевеод на русский

2. **Содержание (TOC)**:
   - В начале каждого файла документации добавь раздел с оглавлением и ссылками на функции и методы внутри кода
   - Структура оглавления должна включать ссылки на все основные разделы документации модуля.

3. **Форматирование документации**:
   - Используй синтаксис Markdown для всех заголовков, списков и ссылок.
   - Для документирования классов, функций и методов включай структурированные разделы с описаниями, деталями параметров, возвращаемых значений и вызываемых исключений. Пример:

    ## Классы

    ### `class_name
    Описание назначения класса
        **Наследует** 
            Если класс наследует другой - дай описание наследования

         **Аттрибуты**:
            param1 (str): Описание параметров (атрибутов) класса

         **Методы**:
            function_1(): Описание назаначения функций/методов класса


     ## Функции

     ### `function_name`

     **Назначение**: Назначение функции.


     **Параметры**:
     - `param` (str): Описание параметра `param`.
     - `param1` (Optional[str | dict | str], optional): Описание параметра `param1`. По умолчанию `None`.

     **Возвращает**:
     - `dict | None`: Описание возвращаемого значения.

     **Вызывает исключения**:
     - `SomeError`: Описание ситуации, в которой возникает исключение `SomeError`.

     Если внутри функции есть внутренние фуйнкции - рассмотри их по отдельности каждую
     **Внутренние функции**: Если есть

     

     **Как работает функция**:
     - Подробно объясни назначиение функции. Сдеалай подробное описание того, какие действия преобразования происходит в теле функции


     **Примеры**:
     - Создай несколько примеров вызова функции с разными параметрами, которые передающтся в функцию
     
     
4. **Заголовки разделов**:
   - Используйте заголовки первого уровня (`#`), второго уровня (`##`), третьего уровня (`###`) и четвёртого уровня (`####`) последовательно на протяжении всего файла.

5. **Пример файла**:

   # Название модуля

   ## Обзор

   Краткое описание назначения модуля.

   ## Подорбней

   Более подробное описание. Объясни как и зачем используется данный код в проекте. 
   Анализируй предоставленный тебе ранее код

   ## Классы

   ### `ClassName`

   **Описание**: Описание класса.
   **Наследует**:
   **Атрибуты**:
   **Параметры**:

    **Принцип работы**:
        Объясни  работу класса. Если класс сложный сдеалай подорбный разбор кода

   Сделай документацию для КАЖДОЙ функции или метода. Объясни назначение каждой переменной.
   - Все комментарии и docstring должны быть на русском языке в формате UTF-8. Если в оригинальном коде текст написан на английском - переводи его на русский

   **Методы**: # если есть методы
   - `method_name`: Краткое описание метода.   
   - `method_name`: Краткое описание метода.
   **Параметры**: # если есть параметры
   - `param` (str): Описание параметра `param`. 
   - `param1` (Optional[str | dict | str], optional): Описание параметра `param1`. По умолчанию `None`.
   **Примеры**
   - Примеры определения класса и работы с классом


   ## Методы класса

   ### `function_name`

   ```python
   def my_func(param1:str, param2:Optional[int] = 0) -> bool:
       """ Функция выполняет некоторое действия... <Тут Ты пишешь что именно делает функция> 
       Args:
           param1 (str): Описание параметра `param1`.
           param2 (Optional[int], optional): Описание параметра `param2`. По умолчанию 0.
       Returns:
           bool: Описание возвращаемого значения. Возвращает `True` или `False`.

        Raises:
             Ошибка выполнение

        Example:
            Примеры вызовов со всем спектром параметров. которы можно передать в функцию

       """
       - Не отдавай код функции. Только документацию и примеры вызова функции;
       - Все комментарии и docstring должны быть на русском языке в формате UTF-8
   ```


   ## Параметры класса
   - `param` (str): Более подробное Описание параметра `param`.
   - `param1` (Optional[str | dict | str], optional): Более подробное Описание параметра `param1`. По умолчанию `None`.

 

   **Примеры**: # Все возможные варианты примеров вызова функции с разными параметрами

   -------------------------------------------------------------------------------------
   

## Твое поведение при анализе кода:
- внутри кода ты можешь встретить выражение между `<` `>`. Например: <инструкция для модели gemini:Загрузка описаний товаров в PrestaShop.>, <далее, если есть>. Это заготовки, куда ты вставляешь релевантное значение
- всегда смотри системную инструкцию для обработки кода проекта `hypotez`;
- анализируй расположение файла в проекте. Это поможет понять его назначение и взаимосвязь с другими файлами. Расположение файла ты найдешь в самой превой строке кода, начинающейся с `## \\file /...`;
- запоминай предоставленный код и анализируй его связь с другими частями проекта;
- В этой инструкции не надо предлагать улучшение кода. Четко следуй пункту 5. **Пример файла** при составлении ответа 

# КОНЕЦ ИНСТРУКЦИИ
```

# Модуль для сбора и копирования иерархии файлов

## Обзор

Этот модуль предназначен для рекурсивного обхода директории `src/utils`, сбора иерархии файлов с определенными расширениями и копирования их в директорию `prod`. Он также создает JSON-файл с иерархией собранных файлов.

## Подробнее

Модуль используется для сбора структуры файлов в директории `src/utils` и их копирования в директорию `prod`. Это может быть полезно для создания структуры проекта для продакшн-окружения или для других целей, где требуется копия файлов с сохранением их иерархии.

## Функции

### `collect_and_copy_files`

**Назначение**: Рекурсивно обходит указанную директорию, собирает иерархию файлов и копирует файлы с определенными расширениями в целевую директорию.

**Параметры**:

-   `directory` (Path): Путь к директории, которую нужно обойти.
-   `target_directory` (Path): Путь к целевой директории, в которую будут скопированы файлы.

**Возвращает**:

-   `dict`: Словарь, представляющий иерархию файлов, где ключи - имена файлов и папок.

**Как работает функция**:

1.  Инициализирует пустой словарь `hierarchy` для хранения иерархии файлов.
2.  Перебирает все элементы (файлы и поддиректории) в заданной директории.
3.  Если элемент является директорией:
    *   Проверяет, не является ли имя директории одним из исключенных (`profiles`, `__pycache__`, `_experiments`) и не начинается ли с `___`, а также не содержит ли символ `*`.
    *   Если директория не исключена, рекурсивно вызывает `collect_and_copy_files` для этой директории и сохраняет результат в словаре `hierarchy` под ключом имени директории.
4.  Если элемент является файлом:
    *   Проверяет, имеет ли файл одно из разрешенных расширений (`.py`, `.json`, `.md`, `.dot`, `.mer`), не начинается ли его имя с `___`, и не содержит ли символ `*`, `(`, или `)`.
    *   Если файл соответствует условиям, добавляет его имя в словарь `hierarchy` со значением `None`.
    *   Формирует путь к файлу в целевой директории.
    *   Создает родительские директории для целевого файла, если они не существуют.
    *   Копирует файл в целевую директорию с сохранением метаданных.
5.  Возвращает словарь `hierarchy`.

```python
def collect_and_copy_files(directory: Path, target_directory: Path) -> dict:
    """
    Рекурсивно обходит указанную директорию, собирает иерархию файлов и копирует файлы с определенными расширениями в целевую директорию.

    Args:
        directory (Path): Путь к директории, которую нужно обойти.
        target_directory (Path): Путь к целевой директории, в которую будут скопированы файлы.

    Returns:
        dict: Словарь, представляющий иерархию файлов, где ключи - имена файлов и папок.
    """
    ...
```

### `main`

**Назначение**: Определяет исходную и целевую директории, вызывает функцию `collect_and_copy_files` для сбора и копирования файлов, и сохраняет иерархию файлов в JSON-файл.

**Как работает функция**:

1.  Определяет исходную директорию `src_directory` как `src/utils` относительно корневой директории проекта.
2.  Определяет целевую директорию `project_structure_directory` как `prod` внутри `src_directory`.
3.  Вызывает функцию `collect_and_copy_files` для сбора иерархии файлов и их копирования в целевую директорию.
4.  Определяет путь к файлу `file_hierarchy.json` внутри `project_structure_directory`, в который будет сохранена иерархия.
5.  Сохраняет иерархию файлов в JSON-файл с использованием функции `j_dumps`.

```python
def main():
    """
    Определяет исходную и целевую директории, вызывает функцию `collect_and_copy_files` для сбора и копирования файлов,
    и сохраняет иерархию файлов в JSON-файл.
    """
    ...
```

## Запуск

```python
if __name__ == "__main__":
    main()
```

При запуске этого скрипта будет вызвана функция `main`, которая соберет иерархию файлов из директории `src/utils`, скопирует их в директорию `prod`, и сохранит иерархию в файл `file_hierarchy.json`.

## Примеры

### Пример структуры директории

Предположим, что структура директории `src/utils` выглядит следующим образом:

```
src/utils/
├── file1.py
├── file2.json
├── subdir1/
│   ├── file3.py
│   └── file4.md
└── subdir2/
    └── file5.dot
```

После выполнения скрипта, в директории `prod` будет создана следующая структура:

```
prod/
├── file1.py
├── file2.json
├── subdir1/
│   ├── file3.py
│   └── file4.md
└── subdir2/
    └── file5.dot
```

И файл `file_hierarchy.json` будет содержать JSON-представление этой структуры.

### Содержимое `file_hierarchy.json`

```json
{
    "file1.py": null,
    "file2.json": null,
    "subdir1": {
        "file3.py": null,
        "file4.md": null
    },
    "subdir2": {
        "file5.dot": null
    }
}