# Модуль для обработки данных о товарах и их публикации в Facebook

## Обзор

Модуль `quotation_builder.py` предназначен для обработки данных о товарах, полученных от различных поставщиков. Он содержит класс `QuotationBuilder`, который отвечает за извлечение, разбор и сохранение информации о товарах, обработку данных с использованием ИИ-модели, а также интеграцию с Facebook для публикации объявлений о товарах.

## Подробнее

**Назначение**:

Этот модуль используется для автоматизации процесса создания объявлений о товарах в Facebook. Он позволяет:

- Извлекать данные о товарах из различных источников (например, с веб-сайтов поставщиков).
- Обрабатывать данные с использованием ИИ-модели для улучшения описаний товаров.
- Сохранять обработанные данные о товарах в файлах.
- Публиковать объявления о товарах в Facebook.

**Принцип работы**:

Модуль работает следующим образом:

1. **Инициализация**: При создании экземпляра класса `QuotationBuilder` передаются необходимые параметры, такие как имя процесса обработки, имя вебдрайвера и оконный режим. Модуль подгружает конфигурационный файл и ИИ-модель. 
2. **Извлечение данных о товарах**:  Извлекает данные о товарах из различных источников (например, с веб-сайтов поставщиков).
3. **Обработка данных**:  Преобразует данные о товарах в удобный формат для ИИ-модели.
4. **Обработка с помощью ИИ**:  Обрабатывает данные о товарах с помощью ИИ-модели, чтобы улучшить описания товаров.
5. **Сохранение данных**:  Сохраняет обработанные данные о товарах в файлах.
6. **Публикация в Facebook**:  Создает объявления о товарах в Facebook.

**Зависимости**:

Модуль зависит от следующих модулей:

- `bs4`: Для парсинга HTML-кода.
- `jinja2`: Для обработки шаблонов.
- `requests`: Для отправки HTTP-запросов.
- `asyncio`: Для выполнения задач асинхронно.
- `random`: Для генерации случайных чисел.
- `shutil`: Для работы с файлами.
- `Pathlib`: Для работы с путями к файлам.
- `telebot`: Для работы с Telegram.
- `src.utils.jjson`: Для работы с JSON-файлами.
- `src.utils.file`: Для работы с файлами.
- `src.utils.image`: Для работы с изображениями.
- `src.logger.logger`: Для ведения журнала.

## Классы

### `QuotationBuilder`

**Описание**: Класс `QuotationBuilder` отвечает за обработку данных о товарах.

**Наследует**: 

**Атрибуты**:

- `driver (Driver)`: Экземпляр Selenium WebDriver.
- `export_path (Path)`: Путь для экспорта данных.
- `products_list (List[dict])`: Список обработанных данных о товарах.

**Методы**:

- `__init__(self, mexiron_name:Optional[str] = gs.now, driver:Optional[Firefox | Playwrid | str] = None,  **kwargs)`: Инициализирует класс `QuotationBuilder` с необходимыми компонентами.
- `convert_product_fields(self, f: ProductFields) -> dict`: Конвертирует поля товара в словарь.
- `process_llm(self, products_list: List[str], lang:str,  attempts: int = 3) -> tuple | bool`: Обрабатывает список данных о товарах с помощью ИИ-модели.
- `process_llm_async(self, products_list: List[str], lang:str,  attempts: int = 3) -> tuple | bool`:  Обрабатывает список данных о товарах с помощью ИИ-модели асинхронно.
- `save_product_data(self, product_data: dict) -> bool`:  Сохраняет данные о товарах в файл.
- `post_facebook_async(self, mexiron:SimpleNamespace) -> bool`:  Публикует объявления о товарах в Facebook.

### `Config`

**Описание**: Класс `Config` хранит конфигурационные данные. 

**Атрибуты**:

- `ENDPOINT (str)`:  Имя точки входа.

**Пример**:

```python
# Создание экземпляра класса QuotationBuilder
quotation = QuotationBuilder(mexiron_name='250203025325520')
```

**Примеры работы**:

**Пример 1: Обработка данных о товарах**

```python
# Получение данных о товарах
products_data = quotation.get_products_data()

# Обработка данных с помощью ИИ-модели
processed_products = quotation.process_llm(products_data, lang='ru')

# Сохранение обработанных данных
quotation.save_product_data(processed_products)
```

**Пример 2: Публикация объявлений в Facebook**

```python
# Получение данных о товарах
mexiron_data = quotation.get_mexiron_data()

# Публикация объявлений в Facebook
quotation.post_facebook_async(mexiron_data)
```

## Функции

### `main()`

**Назначение**:  Функция `main()`  инициализирует класс `QuotationBuilder` и запускает процесс обработки данных о товарах.

**Параметры**:  

**Возвращает**:  

**Вызывает исключения**:

**Примеры**:

```python
if __name__ == "__main__":
    main()
```

## Параметры

- `mexiron_name` (Optional[str]):  Имя процесса обработки. 
- `driver` (Optional[Firefox | Playwrid | str]):  Имя вебдрайвера. 
- `window_mode` (Optional[str]): Оконный режим вебдрайвера. 
- `products_list` (List[str]):  Список данных о товарах в формате строки.
- `lang` (str): Язык (например, 'ru' или 'he').
- `attempts` (int, optional):  Количество попыток повтора в случае ошибки.

## Как работает функция `process_llm`

Функция `process_llm` выполняет следующие действия:

1. **Считывает инструкцию для модели ИИ**:  Считывает инструкцию для модели ИИ из файла `command_instruction_mexiron_lang.md`, где `lang` - язык, который нужно использовать.
2. **Создает запрос**:  Создает запрос к модели ИИ, объединяя инструкцию и список данных о товарах.
3. **Отправляет запрос**: Отправляет запрос к модели ИИ.
4. **Обрабатывает ответ**:  Обрабатывает ответ от модели ИИ, парсит его в формат JSON и возвращает результат.
5. **Повторные попытки**:  Если модель возвращает невалидный результат, функция делает несколько попыток повтора, уменьшая количество попыток при каждом последующем вызове.

**Пример**:

```python
# Список данных о товарах
products_list = [
    {
        'product_name': 'Товар 1',
        'product_id': '12345',
        'description': 'Описание товара 1',
        'specification': 'Спецификация товара 1',
        'local_image_path': 'path/to/image.jpg'
    },
    {
        'product_name': 'Товар 2',
        'product_id': '67890',
        'description': 'Описание товара 2',
        'specification': 'Спецификация товара 2',
        'local_image_path': 'path/to/image.jpg'
    }
]

# Обработка данных с помощью ИИ-модели
processed_products = quotation.process_llm(products_list, lang='ru')