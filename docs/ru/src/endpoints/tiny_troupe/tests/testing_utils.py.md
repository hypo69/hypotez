# Модуль `testing_utils`

## Обзор

Модуль `testing_utils` содержит набор утилитных функций и фикстур, предназначенных для облегчения тестирования в проекте `hypotez`. Он предоставляет инструменты для кэширования результатов API, управления файлами, проверки действий и стимулов в симуляциях, а также для сравнения конфигураций агентов.

## Подробнее

Этот модуль предоставляет набор инструментов, необходимых для написания эффективных и надежных тестов, облегчая процесс тестирования различных компонентов проекта `hypotez`. Он включает в себя функции для управления файлами и каталогами, проверки содержимого действий и стимулов в симуляциях, а также для создания тестовых сред с предопределенными агентами и мирами.

## Содержание

- [Константы](#константы)
- [Кэширование](#кэширование)
- [Управление файлами](#управление-файлами)
- [Утилиты для проверки симуляций](#утилиты-для-проверки-симуляций)
- [Проверка истинности утверждений](#проверка-истинности-утверждений)
- [Создание сообщений для тестов](#создание-сообщений-для-тестов)
- [Сравнение агентов](#сравнение-агентов)
- [Получение имени агента](#получение-имени-агента)
- [I/O утилиты](#io-утилиты)
- [Фикстуры pytest](#фикстуры-pytest)

## Константы

### `CACHE_FILE_NAME`
```python
CACHE_FILE_NAME = "tests_cache.pickle"
```
Имя файла, используемого для кэширования результатов API тестов.

### `EXPORT_BASE_FOLDER`
```python
EXPORT_BASE_FOLDER = os.path.join(os.path.dirname(__file__), "outputs/exports")
```
Путь к базовой папке для экспорта результатов тестов.

### `TEMP_SIMULATION_CACHE_FILE_NAME`
```python
TEMP_SIMULATION_CACHE_FILE_NAME = os.path.join(os.path.dirname(__file__), "simulation_test_case.cache.json")
```
Имя файла, используемого для кэширования тестовых случаев симуляции.

## Кэширование

Блок кода отвечает за настройку кэширования результатов API для тестов.

- Если `conftest.refresh_cache` истинно, то файл кэша `CACHE_FILE_NAME` удаляется.
- Если `conftest.use_cache` истинно, то кэширование API включается с использованием файла `CACHE_FILE_NAME`. В противном случае кэширование отключается.

## Управление файлами

### `remove_file_if_exists`

```python
def remove_file_if_exists(file_path: str) -> None:
    """
    Удаляет файл по указанному пути, если он существует.

    Args:
        file_path (str): Путь к файлу, который нужно удалить.

    Returns:
        None
    """
```
Удаляет файл, если он существует.

## Утилиты для проверки симуляций

### `contains_action_type`

```python
def contains_action_type(actions: list, action_type: str) -> bool:
    """
    Проверяет, содержит ли список действий действие указанного типа.

    Args:
        actions (list): Список действий для проверки.
        action_type (str): Тип действия, которое нужно найти.

    Returns:
        bool: `True`, если список содержит действие указанного типа, иначе `False`.
    """
```

**Назначение**: Проверяет, содержит ли список действий (`actions`) действие определенного типа (`action_type`).

**Параметры**:
- `actions` (list): Список действий, в котором производится поиск.
- `action_type` (str): Тип действия, наличие которого проверяется.

**Возвращает**:
- `bool`: `True`, если действие указанного типа найдено в списке, `False` в противном случае.

**Как работает функция**:
Функция перебирает все элементы списка `actions` и проверяет, совпадает ли значение ключа `type` вложенного словаря `action["action"]` с заданным типом `action_type`. Если совпадение найдено, функция немедленно возвращает `True`. Если перебор завершается без нахождения совпадения, функция возвращает `False`.

### `contains_action_content`

```python
def contains_action_content(actions: list, action_content: str) -> bool:
    """
    Проверяет, содержит ли список действий действие с указанным содержимым.

    Args:
        actions (list): Список действий для проверки.
        action_content (str): Содержимое действия, которое нужно найти.

    Returns:
        bool: `True`, если список содержит действие с указанным содержимым, иначе `False`.
    """
```

**Назначение**: Проверяет, содержит ли список действий (`actions`) действие, содержащее определенный текст (`action_content`).

**Параметры**:
- `actions` (list): Список действий, в котором производится поиск.
- `action_content` (str): Текст, который должен содержаться в содержимом действия.

**Возвращает**:
- `bool`: `True`, если действие, содержащее указанный текст, найдено в списке, `False` в противном случае.

**Как работает функция**:
Функция перебирает все элементы списка `actions` и проверяет, содержится ли текст `action_content` (в нижнем регистре) во вложенном словаре `action["action"]["content"]` (также в нижнем регистре). Если текст найден, функция немедленно возвращает `True`. Если перебор завершается без нахождения совпадения, функция возвращает `False`.

### `contains_stimulus_type`

```python
def contains_stimulus_type(stimuli: list, stimulus_type: str) -> bool:
    """
    Проверяет, содержит ли список стимулов стимул указанного типа.

    Args:
        stimuli (list): Список стимулов для проверки.
        stimulus_type (str): Тип стимула, который нужно найти.

    Returns:
        bool: `True`, если список содержит стимул указанного типа, иначе `False`.
    """
```

**Назначение**: Проверяет, содержит ли список стимулов (`stimuli`) стимул определенного типа (`stimulus_type`).

**Параметры**:
- `stimuli` (list): Список стимулов, в котором производится поиск.
- `stimulus_type` (str): Тип стимула, наличие которого проверяется.

**Возвращает**:
- `bool`: `True`, если стимул указанного типа найден в списке, `False` в противном случае.

**Как работает функция**:
Функция перебирает все элементы списка `stimuli` и проверяет, совпадает ли значение ключа `type` текущего стимула с заданным типом `stimulus_type`. Если совпадение найдено, функция немедленно возвращает `True`. Если перебор завершается без нахождения совпадения, функция возвращает `False`.

### `contains_stimulus_content`

```python
def contains_stimulus_content(stimuli: list, stimulus_content: str) -> bool:
    """
    Проверяет, содержит ли список стимулов стимул с указанным содержимым.

    Args:
        stimuli (list): Список стимулов для проверки.
        stimulus_content (str): Содержимое стимула, которое нужно найти.

    Returns:
        bool: `True`, если список содержит стимул с указанным содержимым, иначе `False`.
    """
```

**Назначение**: Проверяет, содержит ли список стимулов (`stimuli`) стимул, содержащий определенный текст (`stimulus_content`).

**Параметры**:
- `stimuli` (list): Список стимулов, в котором производится поиск.
- `stimulus_content` (str): Текст, который должен содержаться в содержимом стимула.

**Возвращает**:
- `bool`: `True`, если стимул, содержащий указанный текст, найден в списке, `False` в противном случае.

**Как работает функция**:
Функция перебирает все элементы списка `stimuli` и проверяет, содержится ли текст `stimulus_content` (в нижнем регистре) в содержимом текущего стимула (также в нижнем регистре). Если текст найден, функция немедленно возвращает `True`. Если перебор завершается без нахождения совпадения, функция возвращает `False`.

### `terminates_with_action_type`

```python
def terminates_with_action_type(actions: list, action_type: str) -> bool:
    """
    Проверяет, завершается ли список действий действием указанного типа.

    Args:
        actions (list): Список действий для проверки.
        action_type (str): Тип действия, которым должен завершаться список.

    Returns:
        bool: `True`, если список завершается действием указанного типа, иначе `False`.
    """
```

**Назначение**: Проверяет, завершается ли список действий (`actions`) действием определенного типа (`action_type`).

**Параметры**:
- `actions` (list): Список действий, который необходимо проверить.
- `action_type` (str): Тип действия, которым должен заканчиваться список.

**Возвращает**:
- `bool`: `True`, если список завершается действием указанного типа, `False` в противном случае.

**Как работает функция**:
Функция сначала проверяет, является ли список `actions` пустым. Если список пуст, функция возвращает `False`. В противном случае функция сравнивает значение ключа `type` вложенного словаря `action["action"]` последнего элемента списка с заданным типом `action_type`. Если совпадение найдено, функция возвращает `True`, иначе возвращает `False`.

## Проверка истинности утверждений

### `proposition_holds`

```python
def proposition_holds(proposition: str) -> bool:
    """
    Проверяет, является ли данное утверждение истинным с помощью вызова LLM.
    Это можно использовать для проверки текстовых свойств, которые трудно
    проверить механически, например, "текст содержит некоторые идеи для товара".

    Args:
        proposition (str): Утверждение, которое нужно проверить.

    Returns:
        bool: `True`, если утверждение истинно, иначе `False`.

    Raises:
        Exception: Если LLM возвращает неожиданный результат.
    """
```

**Назначение**: Проверяет, является ли утверждение (`proposition`) истинным, используя LLM (Large Language Model).

**Параметры**:
- `proposition` (str): Утверждение, которое необходимо проверить.

**Возвращает**:
- `bool`: `True`, если LLM считает утверждение истинным, `False` в противном случае.

**Вызывает исключения**:
- `Exception`: Если LLM возвращает результат, который не начинается с "true" или "false".

**Как работает функция**:
1. Функция определяет два запроса: `system_prompt` и `user_prompt`. `system_prompt` инструктирует LLM проверить, является ли утверждение истинным или ложным. `user_prompt` содержит само утверждение.
2. Функция объединяет `system_prompt` и `user_prompt` в список сообщений.
3. Функция вызывает LLM с помощью `openai_utils.client().send_message(messages)` для получения ответа.
4. Функция извлекает содержимое ответа LLM и очищает его, оставляя только буквенно-цифровые символы.
5. Функция проверяет, начинается ли очищенный ответ с "true" или "false" (без учета регистра). Если ответ начинается с "true", функция возвращает `True`. Если ответ начинается с "false", функция возвращает `False`. В противном случае функция вызывает исключение `Exception` с сообщением об неожиданном результате.

### Внутренние функции
#### `only_alphanumeric`
```python
def only_alphanumeric(string: str) -> str:
    """
    Возвращает строку, содержащую только буквенно-цифровые символы.

    Args:
        string (str): Исходная строка.

    Returns:
        str: Строка, содержащая только буквенно-цифровые символы.
    """
```

**Назначение**: Извлекает из входной строки (`string`) только буквенно-цифровые символы.

**Параметры**:
- `string` (str): Исходная строка, из которой нужно извлечь символы.

**Возвращает**:
- `str`: Строка, содержащая только буквенно-цифровые символы из исходной строки.

**Как работает функция**:
Функция использует генератор списка для итерации по каждому символу во входной строке `string`. Для каждого символа выполняется проверка, является ли он буквенно-цифровым с помощью метода `isalnum()`. Если символ является буквенно-цифровым, он включается в результирующую строку. Затем все отобранные символы объединяются в одну строку, которая и возвращается.

## Создание сообщений для тестов

### `create_test_system_user_message`

```python
def create_test_system_user_message(user_prompt: str, system_prompt: str = "You are a helpful AI assistant.") -> list:
    """
    Создает список, содержащий одно системное сообщение и одно пользовательское сообщение.

    Args:
        user_prompt (str): Текст пользовательского сообщения.
        system_prompt (str): Текст системного сообщения. По умолчанию "You are a helpful AI assistant.".

    Returns:
        list: Список, содержащий системное и пользовательское сообщения.
    """
```

**Назначение**: Создает список сообщений, содержащий системное сообщение и пользовательское сообщение.

**Параметры**:
- `user_prompt` (str): Текст пользовательского запроса.
- `system_prompt` (str): Текст системного сообщения (инструкции для модели). По умолчанию: "You are a helpful AI assistant."

**Возвращает**:
- `list`: Список, содержащий словарь с системным сообщением и (если предоставлен) словарь с пользовательским сообщением.

**Как работает функция**:
1.  Создается список `messages`, содержащий словарь с системным сообщением, где `role` установлено как "system", а `content` - как `system_prompt`.
2.  Если `user_prompt` не равен `None`, то в список `messages` добавляется еще один словарь с пользовательским сообщением, где `role` установлено как "user", а `content` - как `user_prompt`.
3.  Функция возвращает список `messages`.

## Сравнение агентов

### `agents_personas_are_equal`

```python
def agents_personas_are_equal(agent1: TinyPerson, agent2: TinyPerson, ignore_name: bool = False) -> bool:
    """
    Проверяет, идентичны ли конфигурации двух агентов.

    Args:
        agent1 (TinyPerson): Первый агент для сравнения.
        agent2 (TinyPerson): Второй агент для сравнения.
        ignore_name (bool): Если `True`, имя агента игнорируется при сравнении. По умолчанию `False`.

    Returns:
        bool: `True`, если конфигурации агентов идентичны, иначе `False`.
    """
```

**Назначение**: Сравнивает конфигурации двух агентов (`agent1` и `agent2`) и определяет, идентичны ли они.

**Параметры**:
-   `agent1` (`TinyPerson`): Первый агент для сравнения.
-   `agent2` (`TinyPerson`): Второй агент для сравнения.
-   `ignore_name` (`bool`, optional): Флаг, указывающий, следует ли игнорировать имя агента при сравнении. По умолчанию `False`.

**Возвращает**:
-   `bool`: `True`, если конфигурации агентов идентичны, в противном случае `False`.

**Как работает функция**:

1.  Инициализируется список `ignore_keys`, который будет содержать ключи, которые нужно игнорировать при сравнении.
2.  Если параметр `ignore_name` установлен в `True`, в список `ignore_keys` добавляется ключ "name".
3.  Функция перебирает все ключи в словаре `_persona` первого агента (`agent1`).
4.  Для каждого ключа проверяется, находится ли он в списке `ignore_keys`. Если ключ находится в списке, он пропускается.
5.  Если ключ не находится в списке `ignore_keys`, функция сравнивает значение этого ключа в `_persona` первого агента (`agent1._persona[key]`) со значением этого же ключа в `_persona` второго агента (`agent2._persona[key]`).
6.  Если значения не совпадают, функция немедленно возвращает `False`.
7.  Если перебор всех ключей завершается без обнаружения различий, функция возвращает `True`.

## Получение имени агента

### `agent_first_name`

```python
def agent_first_name(agent: TinyPerson) -> str:
    """
    Возвращает имя агента.

    Args:
        agent (TinyPerson): Агент, имя которого нужно получить.

    Returns:
        str: Имя агента.
    """
```

**Назначение**: Извлекает имя агента (`agent`).

**Параметры**:
- `agent` (`TinyPerson`): Агент, у которого нужно получить имя.

**Возвращает**:
- `str`: Имя агента.

**Как работает функция**:
Функция разделяет полное имя агента, хранящееся в атрибуте `name`, на отдельные слова, используя пробел в качестве разделителя. Затем функция возвращает первый элемент полученного списка, который соответствует имени агента.

## I/O утилиты

### `get_relative_to_test_path`

```python
def get_relative_to_test_path(path_suffix: str) -> str:
    """
    Возвращает путь к тестовому файлу с указанным суффиксом.

    Args:
        path_suffix (str): Суффикс пути к файлу.

    Returns:
        str: Полный путь к тестовому файлу.
    """
```

**Назначение**: Формирует абсолютный путь к файлу, расположенному относительно текущего файла с тестами.

**Параметры**:
- `path_suffix` (str): Относительный путь к файлу, который нужно получить.

**Возвращает**:
- `str`: Абсолютный путь к файлу, полученный путем объединения директории текущего файла с тестами и предоставленного суффикса пути.

**Как работает функция**:
Функция использует `os.path.dirname(__file__)` для получения директории, в которой расположен текущий файл. Затем, с помощью `os.path.join()`, объединяет полученную директорию с предоставленным суффиксом `path_suffix`, формируя таким образом полный путь к файлу, расположенному относительно текущего файла с тестами.

## Фикстуры pytest

### `focus_group_world`

```python
@pytest.fixture(scope="function")
def focus_group_world() -> TinyWorld:
    """
    Создает тестовый мир с предопределенными агентами (Лиза, Оскар, Маркос).

    Returns:
        TinyWorld: Объект тестового мира.
    """
```

**Назначение**: Создает и возвращает экземпляр `TinyWorld`, представляющий собой мир с предопределенными агентами для тестирования.

**Возвращает**:
- `TinyWorld`: Объект `TinyWorld`, содержащий агентов Лизу (специалиста по данным), Оскара (архитектора) и Маркоса (врача).

**Как работает функция**:
1.  Импортирует модуль `tinytroupe.examples`, который содержит функции для создания предопределенных агентов.
2.  Создает экземпляр `TinyWorld` с именем "Focus group".
3.  Использует функции из `tinytroupe.examples` для создания агентов: Лизы (специалиста по данным), Оскара (архитектора) и Маркоса (врача).
4.  Добавляет созданных агентов в мир `TinyWorld`.
5.  Возвращает созданный объект `TinyWorld`.

### `setup`

```python
@pytest.fixture(scope="function")
def setup() -> Generator[None, None, None]:
    """
    Выполняет очистку агентов и сред перед каждым тестом.

    Yields:
        None
    """
```

**Назначение**: Фикстура `pytest`, которая очищает агентов и среды перед выполнением каждого теста.

**Как работает функция**:
1.  Очищает список агентов, вызывая метод `TinyPerson.clear_agents()`.
2.  Очищает список сред, вызывая метод `TinyWorld.clear_environments()`.
3.  Использует `yield`, чтобы передать управление тесту. После завершения теста выполнение фикстуры продолжится (в данном случае ничего не происходит).