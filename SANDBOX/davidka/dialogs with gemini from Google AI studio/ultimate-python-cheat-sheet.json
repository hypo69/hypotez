{
  "runSettings": {
    "temperature": 1.0,
    "model": "models/gemini-2.0-flash-exp",
    "candidateCount": 1,
    "topP": 0.95,
    "topK": 40,
    "maxOutputTokens": 8192,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_CIVIC_INTEGRITY",
      "threshold": "BLOCK_LOW_AND_ABOVE"
    }],
    "responseMimeType": "text/plain",
    "enableCodeExecution": false,
    "enableEnhancedCivicAnswers": true,
    "enableSearchAsATool": false,
    "enableBrowseAsATool": false
  },
  "systemInstruction": {
    "text": "Working With Files\n1. Reading a File\nTo read the entire content of a file:\n\nwith open(\u0027example.txt\u0027, \u0027r\u0027) as file:\n    content \u003d file.read()\n    print(content)\n2. Writing to a File\nTo write text to a file, overwriting existing content:\n\nwith open(\u0027example.txt\u0027, \u0027w\u0027) as file:\n    file.write(\u0027Hello, Python!\u0027)\n3. Appending to a File\nTo add text to the end of an existing file:\n\nwith open(\u0027example.txt\u0027, \u0027a\u0027) as file:\n    file.write(\u0027\\nAppend this line.\u0027)\n4. Reading Lines into a List\nTo read a file line by line into a list:\n\nwith open(\u0027example.txt\u0027, \u0027r\u0027) as file:\n    lines \u003d file.readlines()\n    print(lines)\n5. Iterating Over Each Line in a File\nTo process each line in a file:\n\nwith open(\u0027example.txt\u0027, \u0027r\u0027) as file:\n    for line in file:\n        print(line.strip())\n6. Checking If a File Exists\nTo check if a file exists before performing file operations:\n\nimport os\nif os.path.exists(\u0027example.txt\u0027):\n    print(\u0027File exists.\u0027)\nelse:\n    print(\u0027File does not exist.\u0027)\n7. Writing Lists to a File\nTo write each element of a list to a new line in a file:\n\nlines \u003d [\u0027First line\u0027, \u0027Second line\u0027, \u0027Third line\u0027]\nwith open(\u0027example.txt\u0027, \u0027w\u0027) as file:\n    for line in lines:\n        file.write(f\u0027{line}\\n\u0027)\n8. Using With Blocks for Multiple Files\nTo work with multiple files simultaneously using with blocks:\n\nwith open(\u0027source.txt\u0027, \u0027r\u0027) as source, open(\u0027destination.txt\u0027, \u0027w\u0027) as destination:\n    content \u003d source.read()\n    destination.write(content)\n9. Deleting a File\nTo safely delete a file if it exists:\n\nimport os\nif os.path.exists(\u0027example.txt\u0027):\n    os.remove(\u0027example.txt\u0027)\n    print(\u0027File deleted.\u0027)\nelse:\n    print(\u0027File does not exist.\u0027)\n10. Reading and Writing Binary Files\nTo read from and write to a file in binary mode (useful for images, videos, etc.):\n\n# Reading a binary file\nwith open(\u0027image.jpg\u0027, \u0027rb\u0027) as file:\n    content \u003d file.read()\n# Writing to a binary file\nwith open(\u0027copy.jpg\u0027, \u0027wb\u0027) as file:\n    file.write(content)\nWorking With Simple HTTP APIs\n1. Basic GET Request\nTo fetch data from an API endpoint using a GET request:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/data\u0027)\ndata \u003d response.json()  # Assuming the response is JSON\nprint(data)\n2. GET Request with Query Parameters\nTo send a GET request with query parameters:\n\nimport requests\nparams \u003d {\u0027key1\u0027: \u0027value1\u0027, \u0027key2\u0027: \u0027value2\u0027}\nresponse \u003d requests.get(\u0027https://api.example.com/search\u0027, params\u003dparams)\ndata \u003d response.json()\nprint(data)\n3. Handling HTTP Errors\nTo handle possible HTTP errors gracefully:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/data\u0027)\ntry:\n    response.raise_for_status()  # Raises an HTTPError if the status is 4xx, 5xx\n    data \u003d response.json()\n    print(data)\nexcept requests.exceptions.HTTPError as err:\n    print(f\u0027HTTP Error: {err}\u0027)\n4. Setting Timeout for Requests\nTo set a timeout for API requests to avoid hanging indefinitely:\n\nimport requests\ntry:\n    response \u003d requests.get(\u0027https://api.example.com/data\u0027, timeout\u003d5)  # Timeout in seconds\n    data \u003d response.json()\n    print(data)\nexcept requests.exceptions.Timeout:\n    print(\u0027The request timed out\u0027)\n5. Using Headers in Requests\nTo include headers in your request (e.g., for authorization):\n\nimport requests\nheaders \u003d {\u0027Authorization\u0027: \u0027Bearer YOUR_ACCESS_TOKEN\u0027}\nresponse \u003d requests.get(\u0027https://api.example.com/protected\u0027, headers\u003dheaders)\ndata \u003d response.json()\nprint(data)\n6. POST Request with JSON Payload\nTo send data to an API endpoint using a POST request with a JSON payload:\n\nimport requests\npayload \u003d {\u0027key1\u0027: \u0027value1\u0027, \u0027key2\u0027: \u0027value2\u0027}\nheaders \u003d {\u0027Content-Type\u0027: \u0027application/json\u0027}\nresponse \u003d requests.post(\u0027https://api.example.com/submit\u0027, json\u003dpayload, headers\u003dheaders)\nprint(response.json())\n7. Handling Response Encoding\nTo handle the response encoding properly:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/data\u0027)\nresponse.encoding \u003d \u0027utf-8\u0027  # Set encoding to match the expected response format\ndata \u003d response.text\nprint(data)\n8. Using Sessions with Requests\nTo use a session object for making multiple requests to the same host, which can improve performance:\n\nimport requests\nwith requests.Session() as session:\n    session.headers.update({\u0027Authorization\u0027: \u0027Bearer YOUR_ACCESS_TOKEN\u0027})\n    response \u003d session.get(\u0027https://api.example.com/data\u0027)\n    print(response.json())\n9. Handling Redirects\nTo handle or disable redirects in requests:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/data\u0027, allow_redirects\u003dFalse)\nprint(response.status_code)\n10. Streaming Large Responses\nTo stream a large response to process it in chunks, rather than loading it all into memory:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/large-data\u0027, stream\u003dTrue)\nfor chunk in response.iter_content(chunk_size\u003d1024):\n    process(chunk)  # Replace \u0027process\u0027 with your actual processing function\nWorking With Lists\n1. Creating a List\nTo conjure a list into being:\n\n# A list of mystical elements\nelements \u003d [\u0027Earth\u0027, \u0027Air\u0027, \u0027Fire\u0027, \u0027Water\u0027]\n2. Appending to a List\nTo append a new element to the end of a list:\n\nelements.append(\u0027Aether\u0027)\n3. Inserting into a List\nTo insert an element at a specific position in the list:\n\n# Insert \u0027Spirit\u0027 at index 1\nelements.insert(1, \u0027Spirit\u0027)\n4. Removing from a List\nTo remove an element by value from the list:\n\nelements.remove(\u0027Earth\u0027)  # Removes the first occurrence of \u0027Earth\u0027\n5. Popping an Element from a List\nTo remove and return an element at a given index (default is the last item):\n\nlast_element \u003d elements.pop()  # Removes and returns the last element\n6. Finding the Index of an Element\nTo find the index of the first occurrence of an element:\n\nindex_of_air \u003d elements.index(\u0027Air\u0027)\n7. List Slicing\nTo slice a list, obtaining a sub-list:\n\n# Get elements from index 1 to 3\nsub_elements \u003d elements[1:4]\n8. List Comprehension\nTo create a new list by applying an expression to each element of an existing one:\n\n# Create a new list with lengths of each element\nlengths \u003d [len(element) for element in elements]\n9. Sorting a List\nTo sort a list in ascending order (in-place):\n\nelements.sort()\n10. Reversing a List\nTo reverse the elements of a list in-place:\n\nelements.reverse()\nWorking With Dictionaries\n1. Creating a Dictionary\nTo forge a new dictionary:\n\n# A tome of elements and their symbols\nelements \u003d {\u0027Hydrogen\u0027: \u0027H\u0027, \u0027Helium\u0027: \u0027He\u0027, \u0027Lithium\u0027: \u0027Li\u0027}\n2. Adding or Updating Entries\nTo add a new entry or update an existing one:\n\nelements[\u0027Carbon\u0027] \u003d \u0027C\u0027  # Adds \u0027Carbon\u0027 or updates its value to \u0027C\u0027\n3. Removing an Entry\nTo banish an entry from the dictionary:\n\ndel elements[\u0027Lithium\u0027]  # Removes the key \u0027Lithium\u0027 and its value\n4. Checking for Key Existence\nTo check if a key resides within the dictionary:\n\nif \u0027Helium\u0027 in elements:\n    print(\u0027Helium is present\u0027)\n5. Iterating Over Keys\nTo iterate over the keys in the dictionary:\n\nfor element in elements:\n    print(element)  # Prints each key\n6. Iterating Over Values\nTo traverse through the values in the dictionary:\n\nfor symbol in elements.values():\n    print(symbol)  # Prints each value\n7. Iterating Over Items\nTo journey through both keys and values together:\n\nfor element, symbol in elements.items():\n    print(f\u0027{element}: {symbol}\u0027)\n8. Dictionary Comprehension\nTo conjure a new dictionary through an incantation over an iterable:\n\n# Squares of numbers from 0 to 4\nsquares \u003d {x: x**2 for x in range(5)}\n9. Merging Dictionaries\nTo merge two or more dictionaries, forming a new alliance of their entries:\n\nalchemists \u003d {\u0027Paracelsus\u0027: \u0027Mercury\u0027}\nphilosophers \u003d {\u0027Plato\u0027: \u0027Aether\u0027}\nmerged \u003d {**alchemists, **philosophers}  # Python 3.5+\n10. Getting a Value with Default\nTo retrieve a value safely, providing a default for absent keys:\n\nelement \u003d elements.get(\u0027Neon\u0027, \u0027Unknown\u0027)  # Returns \u0027Unknown\u0027 if \u0027Neon\u0027 is not found\nWorking With The Operating System\n1. Navigating File Paths\nTo craft and dissect paths, ensuring compatibility across realms (operating systems):\n\nimport os\n# Craft a path compatible with the underlying OS\npath \u003d os.path.join(\u0027mystic\u0027, \u0027forest\u0027, \u0027artifact.txt\u0027)\n# Retrieve the tome\u0027s directory\ndirectory \u003d os.path.dirname(path)\n# Unveil the artifact\u0027s name\nartifact_name \u003d os.path.basename(path)\n2. Listing Directory Contents\nTo reveal all entities within a mystical directory:\n\nimport os\ncontents \u003d os.listdir(\u0027enchanted_grove\u0027)\nprint(contents)\n3. Creating Directories\nTo conjure new directories within the fabric of the filesystem:\n\nimport os\n# create a single directory\nos.mkdir(\u0027alchemy_lab\u0027)\n# create a hierarchy of directories\nos.makedirs(\u0027alchemy_lab/potions/elixirs\u0027)\n4. Removing Files and Directories\nTo erase files or directories, banishing their essence:\n\nimport os\n# remove a file\nos.remove(\u0027unnecessary_scroll.txt\u0027)\n# remove an empty directory\nos.rmdir(\u0027abandoned_hut\u0027)\n# remove a directory and its contents\nimport shutil\nshutil.rmtree(\u0027cursed_cavern\u0027)\n5. Executing Shell Commands\nTo invoke the shell‚Äôs ancient powers directly from Python:\n\nimport subprocess\n# Invoke the \u0027echo\u0027 incantation\nresult \u003d subprocess.run([\u0027echo\u0027, \u0027Revealing the arcane\u0027], capture_output\u003dTrue, text\u003dTrue)\nprint(result.stdout)\n6. Working with Environment Variables\nTo read and inscribe upon the ethereal environment variables:\n\nimport os\n# Read the \u0027PATH\u0027 variable\npath \u003d os.environ.get(\u0027PATH\u0027)\n# Create a new environment variable\nos.environ[\u0027MAGIC\u0027] \u003d \u0027Arcane\u0027\n7. Changing the Current Working Directory\nTo shift your presence to another directory within the filesystem:\n\nimport os\n# Traverse to the \u0027arcane_library\u0027 directory\nos.chdir(\u0027arcane_library\u0027)\n8. Path Existence and Type\nTo discern the existence of paths and their nature ‚Äî be they file or directory:\n\nimport os\n# Check if a path exists\nexists \u003d os.path.exists(\u0027mysterious_ruins\u0027)\n# Ascertain if the path is a directory\nis_directory \u003d os.path.isdir(\u0027mysterious_ruins\u0027)\n# Determine if the path is a file\nis_file \u003d os.path.isfile(\u0027ancient_manuscript.txt\u0027)\n9. Working with Temporary Files\nTo summon temporary files and directories, fleeting and ephemeral:\n\nimport tempfile\n# Create a temporary file\ntemp_file \u003d tempfile.NamedTemporaryFile(delete\u003dFalse)\nprint(temp_file.name)\n# Erect a temporary directory\ntemp_dir \u003d tempfile.TemporaryDirectory()\nprint(temp_dir.name)\n10. Getting System Information\nTo unveil information about the host system, its name, and the enchantments it supports:\n\nimport os\nimport platform\n# Discover the operating system\nos_name \u003d os.name  # \u0027posix\u0027, \u0027nt\u0027, \u0027java\u0027\n# Unearth detailed system information\nsystem_info \u003d platform.system()  # \u0027Linux\u0027, \u0027Windows\u0027, \u0027Darwin\u0027\nWorking With CLI ‚Äî STDIN, STDOUT, STDERR\n1. Reading User Input\nGetting input from STDIN:\n\nuser_input \u003d input(\"Impart your wisdom: \")\nprint(f\"You shared: {user_input}\")\n2. Printing to STDOUT\nTo print messages to the console:\n\nprint(\"Behold, the message of the ancients!\")\n3. Formatted Printing\nTo weave variables into your messages with grace and precision:\n\nname \u003d \"Merlin\"\nage \u003d 300\nprint(f\"{name}, of {age} years, speaks of forgotten lore.\")\n4. Reading Lines from STDIN\nTrim whitespaces line by line from STDIN:\n\nimport sys\nfor line in sys.stdin:\n    print(f\"Echo from the void: {line.strip()}\")\n5. Writing to STDERR\nTo send message to STDERR:\n\nimport sys\nsys.stderr.write(\"Beware! The path is fraught with peril.\\n\")\n6. Redirecting STDOUT\nTo redirect the STDOUT:\n\nimport sys\noriginal_stdout \u003d sys.stdout  # Preserve the original STDOUT\nwith open(\u0027mystic_log.txt\u0027, \u0027w\u0027) as f:\n    sys.stdout \u003d f  # Redirect STDOUT to a file\n    print(\"This message is inscribed within the mystic_log.txt.\")\nsys.stdout \u003d original_stdout  # Restore STDOUT to its original glory\n7. Redirecting STDERR\nRedirecting STDERR:\n\nimport sys\nwith open(\u0027warnings.txt\u0027, \u0027w\u0027) as f:\n    sys.stderr \u003d f  # Redirect STDERR\n    print(\"This warning is sealed within warnings.txt.\", file\u003dsys.stderr)\n8. Prompting for Passwords\nTo prompt for passwords:\n\nimport getpass\nsecret_spell \u003d getpass.getpass(\"Whisper the secret spell: \")\n9. Command Line Arguments\nWorking with and parsing command line arguments:\n\nimport sys\n# The script\u0027s name is the first argument, followed by those passed by the invoker\nscript, first_arg, second_arg \u003d sys.argv\nprint(f\"Invoked with the sacred tokens: {first_arg} and {second_arg}\")\n10. Using Argparse for Complex CLI Interactions\nAdding descriptions and options/arguments:\n\nimport argparse\nparser \u003d argparse.ArgumentParser(description\u003d\"Invoke the ancient scripts.\")\nparser.add_argument(\u0027spell\u0027, help\u003d\"The spell to cast\")\nparser.add_argument(\u0027--power\u0027, type\u003dint, help\u003d\"The power level of the spell\")\nargs \u003d parser.parse_args()\nprint(f\"Casting {args.spell} with power {args.power}\")\nWorking With Mathematical Operations and Permutations\n1. Basic Arithmetic Operations\nTo perform basic arithmetic:\n\nsum \u003d 7 + 3  # Addition\ndifference \u003d 7 - 3  # Subtraction\nproduct \u003d 7 * 3  # Multiplication\nquotient \u003d 7 / 3  # Division\nremainder \u003d 7 % 3  # Modulus (Remainder)\npower \u003d 7 ** 3  # Exponentiation\n2. Working with Complex Numbers\nTo work with complex numbers:\n\nz \u003d complex(2, 3)  # Create a complex number 2 + 3j\nreal_part \u003d z.real  # Retrieve the real part\nimaginary_part \u003d z.imag  # Retrieve the imaginary part\nconjugate \u003d z.conjugate()  # Get the conjugate\n3. Mathematical Functions\nCommon math functions:\n\nimport math\nroot \u003d math.sqrt(16)  # Square root\nlogarithm \u003d math.log(100, 10)  # Logarithm base 10 of 100\nsine \u003d math.sin(math.pi / 2)  # Sine of 90 degrees (in radians)\n4. Generating Permutations\nEasy way to generate permutations from a given set:\n\nfrom itertools import permutations\npaths \u003d permutations([1, 2, 3])  # Generate all permutations of the list [1, 2, 3]\nfor path in paths:\n    print(path)\n5. Generating Combinations\nEasy way to generate combinations:\n\nfrom itertools import combinations\ncombos \u003d combinations([1, 2, 3, 4], 2)  # Generate all 2-element combinations\nfor combo in combos:\n    print(combo)\n6. Random Number Generation\nTo get a random number:\n\nimport random\nnum \u003d random.randint(1, 100)  # Generate a random integer between 1 and 100\n7. Working with Fractions\nWhen you need to work with fractions:\n\nfrom fractions import Fraction\nf \u003d Fraction(3, 4)  # Create a fraction 3/4\nprint(f + 1)  # Add a fraction and an integer\n8. Statistical Functions\nTo get Average, Median, and Standard Deviation:\n\nimport statistics\ndata \u003d [1, 2, 3, 4, 5]\nmean \u003d statistics.mean(data)  # Average\nmedian \u003d statistics.median(data)  # Median\nstdev \u003d statistics.stdev(data)  # Standard Deviation\n9. Trigonometric Functions\nTo work with trigonometry:\n\nimport math\nangle_rad \u003d math.radians(60)  # Convert 60 degrees to radians\ncosine \u003d math.cos(angle_rad)  # Cosine of the angle\n10. Handling Infinity and NaN\nTo work with Infinity and NaN:\n\nimport math\ninfinity \u003d math.inf  # Representing infinity\nnot_a_number \u003d math.nan  # Representing a non-number (NaN)\nWorking With Databases\n1. Establishing a Connection\nTo create a connection to a Postgres Database:\n\nimport psycopg2\nconnection \u003d psycopg2.connect(\n    dbname\u003d\u0027your_database\u0027,\n    user\u003d\u0027your_username\u0027,\n    password\u003d\u0027your_password\u0027,\n    host\u003d\u0027your_host\u0027\n)\n2. Creating a Cursor\nTo create a database cursor, enabling the traversal and manipulation of records:\n\ncursor \u003d connection.cursor()\n3. Executing a Query\nSelecting data from Database:\n\ncursor.execute(\"SELECT * FROM your_table\")\n4. Fetching Query Results\nFetching data with a cursor:\n\nrecords \u003d cursor.fetchall()\nfor record in records:\n    print(record)\n5. Inserting Records\nTo insert data into tables in a database:\n\ncursor.execute(\"INSERT INTO your_table (column1, column2) VALUES (%s, %s)\", (\u0027value1\u0027, \u0027value2\u0027))\nconnection.commit()  # Seal the transaction\n6. Updating Records\nTo alter the records:\n\ncursor.execute(\"UPDATE your_table SET column1 \u003d %s WHERE column2 \u003d %s\", (\u0027new_value\u0027, \u0027condition_value\u0027))\nconnection.commit()\n7. Deleting Records\nTo delete records from the table:\n\ncursor.execute(\"DELETE FROM your_table WHERE condition_column \u003d %s\", (\u0027condition_value\u0027,))\nconnection.commit()\n8. Creating a Table\nTo create a new table, defining its structure:\n\ncursor.execute(\"\"\"\n    CREATE TABLE your_new_table (\n        id SERIAL PRIMARY KEY,\n        column1 VARCHAR(255),\n        column2 INTEGER\n    )\n\"\"\")\nconnection.commit()\n9. Dropping a Table\nTo drop a table:\n\ncursor.execute(\"DROP TABLE if exists your_table\")\nconnection.commit()\n10. Using Transactions\nTo use transactions for atomicity:\n\ntry:\n    cursor.execute(\"your first transactional query\")\n    cursor.execute(\"your second transactional query\")\n    connection.commit()  # Commit if all is well\nexcept Exception as e:\n    connection.rollback()  # Rollback in case of any issue\n    print(f\"An error occurred: {e}\")\nWorking With Async IO (Asyncrounous Programming)\n1. Defining an Asynchronous Function\nTo declare an async function:\n\nimport asyncio\nasync def fetch_data():\n    print(\"Fetching data...\")\n    await asyncio.sleep(2)  # Simulate an I/O operation\n    print(\"Data retrieved.\")\n2. Running an Asynchronous Function\nTo invoke an asynchronous function and await them:\n\nasync def main():\n    await fetch_data()\nasyncio.run(main())\n3. Awaiting Multiple Coroutines\nTo invoke multiple async functions and await all:\n\nasync def main():\n    task1 \u003d fetch_data()\n    task2 \u003d fetch_data()\n    await asyncio.gather(task1, task2)\nasyncio.run(main())\n4. Creating Tasks\nTo dispatch tasks:\n\nasync def main():\n    task1 \u003d asyncio.create_task(fetch_data())\n    task2 \u003d asyncio.create_task(fetch_data())\n    await task1\n    await task2\nasyncio.run(main())\n5. Asynchronous Iteration\nTo traverse through asynchronously, allowing time for other functions in between:\n\nasync def fetch_item(item):\n    await asyncio.sleep(1)  # Simulate an I/O operation\n    print(f\"Fetched {item}\")\nasync def main():\n    items \u003d [\u0027potion\u0027, \u0027scroll\u0027, \u0027wand\u0027]\n    for item in items:\n        await fetch_item(item)\nasyncio.run(main())\n6. Using Asynchronous Context Managers\nTo ensure resources are managed within the bounds of an asynchronous function:\n\nasync def async_context_manager():\n    print(\"Entering context\")\n    await asyncio.sleep(1)\n    print(\"Exiting context\")\nasync def main():\n    async with async_context_manager():\n        print(\"Within context\")\nasyncio.run(main())\n7. Handling Exceptions in Asynchronous Code\nTo gracefully catch and manage the errors with async functions:\n\nasync def risky_spell():\n    await asyncio.sleep(1)\n    raise ValueError(\"The spell backfired!\")\nasync def main():\n    try:\n        await risky_spell()\n    except ValueError as e:\n        print(f\"Caught an error: {e}\")\nasyncio.run(main())\n8. Asynchronous Generators\nTo create async generators, each arriving in its own time:\n\nasync def fetch_items():\n    items \u003d [\u0027crystal\u0027, \u0027amulet\u0027, \u0027dagger\u0027]\n    for item in items:\n        await asyncio.sleep(1)\n        yield item\nasync def main():\n    async for item in fetch_items():\n        print(f\"Found {item}\")\nasyncio.run(main())\n9. Using Semaphores\nTo limit the number of concurrent tasks:\n\nasync def guarded_spell(semaphore, item):\n    async with semaphore:\n        print(f\"Processing {item}\")\n        await asyncio.sleep(1)\nasync def main():\n    semaphore \u003d asyncio.Semaphore(2)  # Allow 2 concurrent tasks\n    await asyncio.gather(*(guarded_spell(semaphore, i) for i in range(5)))\nasyncio.run(main())\n10. Event Loops\nTo directly engage with the asynchronous loop, customizing the flow of execution:\n\nasync def perform_spell():\n    print(\"Casting spell...\")\n    await asyncio.sleep(1)\n    print(\"Spell cast.\")\nloop \u003d asyncio.get_event_loop()\ntry:\n    loop.run_until_complete(perform_spell())\nfinally:\n    loop.close()\nWorking With Networks, Sockets, and Network Interfaces\n1. Creating a Socket\nTo create a socket for network communication:\n\nimport socket\ns \u003d socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n2. Connecting to a Remote Server\nTo establish a link with a remote server through the socket:\n\ns.connect((\u0027example.com\u0027, 80))  # Connect to example.com on port 80\n3. Sending Data\nTo dispatch data through the network to a connected entity:\n\ns.sendall(b\u0027Hello, server\u0027)\n4. Receiving Data\nTo receive data from the network:\n\ndata \u003d s.recv(1024)  # Receive up to 1024 bytes\nprint(\u0027Received\u0027, repr(data))\n5. Closing a Socket\nTo gracefully close the socket, severing the network link:\n\ns.close()\n6. Creating a Listening Socket\nTo open a socket that listens for incoming connections:\n\nserversocket \u003d socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserversocket.bind((\u0027localhost\u0027, 8080))  # Bind to localhost on port 8080\nserversocket.listen()  # Listen for incoming connections\n7. Accepting Connections\nTo accept and establish a network link:\n\nclientsocket, address \u003d serversocket.accept()\nprint(f\"Connection from {address} has been established.\")\n8. Non-blocking Socket Operations\nTo set a socket‚Äôs mode to non-blocking:\n\ns.setblocking(False)\n9. Working with UDP Sockets\nTo create a socket for UDP, a protocol for quicker, but less reliable communication:\n\nudp_socket \u003d socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_socket.bind((\u0027localhost\u0027, 8081))  # Bind UDP socket to localhost on port 8081\n10. Enumerating Network Interfaces\nTo discover the names and addresses of the machine‚Äôs network interfaces:\n\nimport socket\nimport netifaces\nfor interface in netifaces.interfaces():\n    addr \u003d netifaces.ifaddresses(interface).get(netifaces.AF_INET)\n    if addr:\n        print(f\"Interface: {interface}, Address: {addr[0][\u0027addr\u0027]}\")\n#\n\nWorking With Pandas Library (Dataframes)\n1. Creating a DataFrame\nTo create a DataFrame with your own columns and data:\n\nimport pandas as pd\ndata \u003d {\n    \u0027Element\u0027: [\u0027Earth\u0027, \u0027Water\u0027, \u0027Fire\u0027, \u0027Air\u0027],\n    \u0027Symbol\u0027: [\u0027üúÉ\u0027, \u0027üúÑ\u0027, \u0027üúÇ\u0027, \u0027üúÅ\u0027]\n}\ndf \u003d pd.DataFrame(data)\n2. Reading Data from a CSV File\nTo read data from a CSV file, transforming it into a DataFrame:\n\ndf \u003d pd.read_csv(\u0027elements.csv\u0027)\n3. Inspecting the First Few Rows\nTo get first rows from dataframe:\n\nprint(df.head())\n4. Selecting Columns\nTo select specific columns from dataframe:\n\nsymbols \u003d df[\u0027Symbol\u0027]\n5. Filtering Rows\nTo sift through the DataFrame, selecting rows that meet your criteria:\n\nfire_elements \u003d df[df[\u0027Element\u0027] \u003d\u003d \u0027Fire\u0027]\n6. Creating New Columns\nTo create new columns in DataFrame derived from the data within:\n\ndf[\u0027Length\u0027] \u003d df[\u0027Element\u0027].apply(len)\n7. Grouping and Aggregating Data\nTo gather your data into groups and extract new data through aggregation:\n\nelement_groups \u003d df.groupby(\u0027Element\u0027).agg({\u0027Length\u0027: \u0027mean\u0027})\n8. Merging DataFrames\nTo weave together two DataFrames, joining them by a shared key:\n\ndf2 \u003d pd.DataFrame({\u0027Element\u0027: [\u0027Earth\u0027, \u0027Fire\u0027], \u0027Quality\u0027: [\u0027Solid\u0027, \u0027Plasma\u0027]})\nmerged_df \u003d pd.merge(df, df2, on\u003d\u0027Element\u0027)\n9. Handling Missing Data\nTo clean your DataFrame, filling the voids where data is absent:\n\ndf.fillna(value\u003d\u0027Unknown\u0027, inplace\u003dTrue)\n10. Pivoting and Reshaping Data\nTo transmute the shape of your DataFrame, revealing hidden patterns and structures with a pivot operation:\n\npivoted_df \u003d df.pivot(index\u003d\u0027Element\u0027, columns\u003d\u0027Symbol\u0027, values\u003d\u0027Length\u0027)\nWorking With Numpy Library (Arrays)\n1. Creating a NumPy Array\nTo create an array:\n\nimport numpy as np\narray \u003d np.array([1, 2, 3, 4, 5])\n2. Array of Zeros or Ones\nTo create an array filled with zeros:\n\nzeros \u003d np.zeros((3, 3))  # A 3x3 array of zeros\nones \u003d np.ones((2, 4))  # A 2x4 array of ones\n3. Creating a Range of Numbers\nTo create a sequence of numbers:\n\nrange_array \u003d np.arange(10, 50, 5)  # From 10 to 50, step by 5\n4. Creating a Linearly Spaced Array\nTo create a series of values, evenly spaced between two bounds:\n\nlinear_spaced \u003d np.linspace(0, 1, 5)  # 5 values from 0 to 1\n5. Reshaping an Array\nTo transmute the shape of an array, altering its dimensions:\n\nreshaped \u003d np.arange(9).reshape(3, 3)  # Reshape a 1D array into a 3x3 2D array\n6. Basic Array Operations\nTo perform elemental manipulations upon the arrays:\n\na \u003d np.array([1, 2, 3])\nb \u003d np.array([4, 5, 6])\nsum \u003d a + b  # Element-wise addition\ndifference \u003d b - a  # Element-wise subtraction\nproduct \u003d a * b  # Element-wise multiplication\n7. Matrix Multiplication\nBasic dot product Operation:\n\nresult \u003d np.dot(a.reshape(1, 3), b.reshape(3, 1))  # Dot product of a and b\n8. Accessing Array Elements\nAccessing array elements with useful syntax:\n\nelement \u003d a[2]  # Retrieve the third element of array \u0027a\u0027\nrow \u003d reshaped[1, :]  # Retrieve the second row of \u0027reshaped\u0027\n9. Boolean Indexing\nTo filter the elements of an array through the sieve of conditionals:\n\nfiltered \u003d a[a \u003e 2]  # Elements of \u0027a\u0027 greater than 2\n10. Aggregations and Statistics\nStatistical operations on np arrays:\n\nmean \u003d np.mean(a)\nmaximum \u003d np.max(a)\nsum \u003d np.sum(a)\nWorking With Matplotlib Library (Data Visualization)\n1. Creating a Basic Plot\nTo create a plot visualization:\n\nimport matplotlib.pyplot as plt\nx \u003d [1, 2, 3, 4, 5]\ny \u003d [1, 4, 9, 16, 25]\nplt.plot(x, y)\nplt.show()\n2. Adding Titles and Labels\nTo create names for axes and title your plot to give better context:\n\nplt.plot(x, y)\nplt.title(\u0027Growth Over Time\u0027)\nplt.xlabel(\u0027Time\u0027)\nplt.ylabel(\u0027Growth\u0027)\nplt.show()\n3. Creating a Scatter Plot\nCreating a scatter plot:\n\nplt.scatter(x, y)\nplt.show()\n4. Customizing Line Styles and Markers\nTo add symbols into your plot, enriching its usefulness:\n\nplt.plot(x, y, linestyle\u003d\u0027--\u0027, marker\u003d\u0027o\u0027, color\u003d\u0027b\u0027)\nplt.show()\n5. Creating Multiple Plots on the Same Axes\nCreating Multiple Plots on the Same Axes:\n\nz \u003d [2, 3, 4, 5, 6]\nplt.plot(x, y)\nplt.plot(x, z)\nplt.show()\n6. Creating Subplots\nTo create subplots:\n\nfig, ax \u003d plt.subplots(2, 1)  # 2 rows, 1 column\nax[0].plot(x, y)\nax[1].plot(x, z)\nplt.show()\n7. Creating a Histogram\nTo create a histogram:\n\ndata \u003d [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\nplt.hist(data, bins\u003d4)\nplt.show()\n8. Adding a Legend\nTo create a legend for the plot:\n\nplt.plot(x, y, label\u003d\u0027Growth\u0027)\nplt.plot(x, z, label\u003d\u0027Decay\u0027)\nplt.legend()\nplt.show()\n9. Customizing Ticks\nTo create your own marks upon the axes, defining the scale of your values:\n\nplt.plot(x, y)\nplt.xticks([1, 2, 3, 4, 5], [\u0027One\u0027, \u0027Two\u0027, \u0027Three\u0027, \u0027Four\u0027, \u0027Five\u0027])\nplt.yticks([0, 5, 10, 15, 20, 25], [\u00270\u0027, \u00275\u0027, \u002710\u0027, \u002715\u0027, \u002720\u0027, \u002725+\u0027])\nplt.show()\n10. Saving Figures\nTo save the plot as a .png:\n\nplt.plot(x, y)\nplt.savefig(\u0027growth_over_time.png\u0027)\nWorking With Scikit-Learn Library (Machine Learning)\n1. Loading a Dataset\nTo work with datasets for your ML experiments\n\nfrom sklearn import datasets\niris \u003d datasets.load_iris()\nX, y \u003d iris.data, iris.target\n2. Splitting Data into Training and Test Sets\nTo divide your data, dedicating portions to training and evaluation:\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test \u003d train_test_split(X, y, test_size\u003d0.2)\n3. Training a Model\nTraining a ML Model using RandomForestClassifier:\n\nfrom sklearn.ensemble import RandomForestClassifier\nmodel \u003d RandomForestClassifier()\nmodel.fit(X_train, y_train)\n4. Making Predictions\nTo access the model predictions:\n\npredictions \u003d model.predict(X_test)\n5. Evaluating Model Performance\nTo evaluate your model, measuring its accuracy in prediction:\n\nfrom sklearn.metrics import accuracy_score\naccuracy \u003d accuracy_score(y_test, predictions)\nprint(f\"Model accuracy: {accuracy}\")\n6. Using Cross-Validation\nTo use Cross-Validation:\n\nfrom sklearn.model_selection import cross_val_score\nscores \u003d cross_val_score(model, X, y, cv\u003d5)\nprint(f\"Cross-validation scores: {scores}\")\n7. Feature Scaling\nTo create the appropriate scales of your features, allowing the model to learn more effectively:\n\nfrom sklearn.preprocessing import StandardScaler\nscaler \u003d StandardScaler()\nX_train_scaled \u003d scaler.fit_transform(X_train)\nX_test_scaled \u003d scaler.transform(X_test)\n8. Parameter Tuning with Grid Search\nTo refine your model‚Äôs parameters, seeking the optimal combination:\n\nfrom sklearn.model_selection import GridSearchCV\nparam_grid \u003d {\u0027n_estimators\u0027: [10, 50, 100], \u0027max_depth\u0027: [None, 10, 20]}\ngrid_search \u003d GridSearchCV(model, param_grid, cv\u003d5)\ngrid_search.fit(X_train, y_train)\n9. Pipeline Creation\nTo streamline your data processing and modeling steps, crafting a seamless flow:\n\nfrom sklearn.pipeline import Pipeline\npipeline \u003d Pipeline([\n    (\u0027scaler\u0027, StandardScaler()),\n    (\u0027classifier\u0027, RandomForestClassifier())\n])\npipeline.fit(X_train, y_train)\n10. Saving and Loading a Model\nTo preserve your model:\n\nimport joblib\n# Saving the model\njoblib.dump(model, \u0027model.joblib\u0027)\n# Loading the model\nloaded_model \u003d joblib.load(\u0027model.joblib\u0027)\nWorking With Plotly Library (Interactive Data Visualization)\n1. Creating a Basic Line Chart\nTo create a line chart:\n\nimport plotly.graph_objs as go\nimport plotly.io as pio\nx \u003d [1, 2, 3, 4, 5]\ny \u003d [1, 4, 9, 16, 25]\nfig \u003d go.Figure(data\u003dgo.Scatter(x\u003dx, y\u003dy, mode\u003d\u0027lines\u0027))\npio.show(fig)\n2. Creating a Scatter Plot\nTo create a scatter plot:\n\nfig \u003d go.Figure(data\u003dgo.Scatter(x\u003dx, y\u003dy, mode\u003d\u0027markers\u0027))\npio.show(fig)\n3. Creating a Bar Chart\nTo Create a Bar Chart:\n\ncategories \u003d [\u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027]\nvalues \u003d [10, 20, 15, 30, 25]\nfig \u003d go.Figure(data\u003dgo.Bar(x\u003dcategories, y\u003dvalues))\npio.show(fig)\n4. Creating a Pie Chart\nTo create a Pie Chart:\n\nlabels \u003d [\u0027Earth\u0027, \u0027Water\u0027, \u0027Fire\u0027, \u0027Air\u0027]\nsizes \u003d [25, 35, 20, 20]\nfig \u003d go.Figure(data\u003dgo.Pie(labels\u003dlabels, values\u003dsizes))\npio.show(fig)\n5. Creating a Histogram\nTo create a Histogram:\n\ndata \u003d [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\nfig \u003d go.Figure(data\u003dgo.Histogram(x\u003ddata))\npio.show(fig)\n6. Creating Box Plots\nTo create a Box Plot:\n\ndata \u003d [1, 2, 2, 3, 4, 4, 4, 5, 5, 6]\nfig \u003d go.Figure(data\u003dgo.Box(y\u003ddata))\npio.show(fig)\n7. Creating Heatmaps\nTo create a heatmap:\n\nimport numpy as np\nz \u003d np.random.rand(10, 10)  # Generate random data\nfig \u003d go.Figure(data\u003dgo.Heatmap(z\u003dz))\npio.show(fig)\n8. Creating 3D Surface Plots\nTo create a 3D Surface Plot:\n\nz \u003d np.random.rand(20, 20)  # Generate random data\nfig \u003d go.Figure(data\u003dgo.Surface(z\u003dz))\npio.show(fig)\n9. Creating Subplots\nTo create a subplot:\n\nfrom plotly.subplots import make_subplots\nfig \u003d make_subplots(rows\u003d1, cols\u003d2)\nfig.add_trace(go.Scatter(x\u003dx, y\u003dy, mode\u003d\u0027lines\u0027), row\u003d1, col\u003d1)\nfig.add_trace(go.Bar(x\u003dcategories, y\u003dvalues), row\u003d1, col\u003d2)\npio.show(fig)\n10. Creating Interactive Time Series\nTo work with Time Series:\n\nimport pandas as pd\ndates \u003d pd.date_range(\u002720230101\u0027, periods\u003d5)\nvalues \u003d [10, 11, 12, 13, 14]\nfig \u003d go.Figure(data\u003dgo.Scatter(x\u003ddates, y\u003dvalues, mode\u003d\u0027lines+markers\u0027))\npio.show(fig)\nWorking With Dates and Times\n1. Getting the Current Date and Time\nTo get the current data and time:\n\nfrom datetime import datetime\nnow \u003d datetime.now()\nprint(f\"Current date and time: {now}\")\n2. Creating Specific Date and Time\nTo conjure a moment from the past or future, crafting it with precision:\n\nspecific_time \u003d datetime(2023, 1, 1, 12, 30)\nprint(f\"Specific date and time: {specific_time}\")\n3. Formatting Dates and Times\nFormatting Dates and Times:\n\nformatted \u003d now.strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(f\"Formatted date and time: {formatted}\")\n4. Parsing Dates and Times from Strings\nParsing Dates and Times from Strings:\n\ndate_string \u003d \"2023-01-01 15:00:00\"\nparsed_date \u003d datetime.strptime(date_string, \"%Y-%m-%d %H:%M:%S\")\nprint(f\"Parsed date and time: {parsed_date}\")\n5. Working with Time Deltas\nTo traverse the distances between moments, leaping forward or backward through time:\n\nfrom datetime import timedelta\ndelta \u003d timedelta(days\u003d7)\nfuture_date \u003d now + delta\nprint(f\"Date after 7 days: {future_date}\")\n6. Comparing Dates and Times\nDate and Times comparisons:\n\nif specific_time \u003e now:\n    print(\"Specific time is in the future.\")\nelse:\n    print(\"Specific time has passed.\")\n7. Extracting Components from a Date/Time\nTo extract dates year, month, day, and more:\n\nyear \u003d now.year\nmonth \u003d now.month\nday \u003d now.day\nhour \u003d now.hour\nminute \u003d now.minute\nsecond \u003d now.second\nprint(f\"Year: {year}, Month: {month}, Day: {day}, Hour: {hour}, Minute: {minute}, Second: {second}\")\n8. Working with Time Zones\nTo work with time zones honoring the local time:\n\nfrom datetime import timezone, timedelta\nutc_time \u003d datetime.now(timezone.utc)\nprint(f\"Current UTC time: {utc_time}\")\n# Adjusting to a specific timezone (e.g., EST)\nest_time \u003d utc_time - timedelta(hours\u003d5)\nprint(f\"Current EST time: {est_time}\")\n9. Getting the Weekday\nTo identify the day of the week:\n\nweekday \u003d now.strftime(\"%A\")\nprint(f\"Today is: {weekday}\")\n10. Working with Unix Timestamps\nTo converse with the ancient epochs, translating their count from the dawn of Unix:\n\ntimestamp \u003d datetime.timestamp(now)\nprint(f\"Current timestamp: {timestamp}\")\n# Converting a timestamp back to a datetime\ndate_from_timestamp \u003d datetime.fromtimestamp(timestamp)\nprint(f\"Date from timestamp: {date_from_timestamp}\")\nAlso, check out the calendar module in Python:\n\nFrom Dates to Holidays: Demystifying the \"calendar\" Module in Python\nYour subtitle here The calendar module in Python is a versatile tool for handling dates, times, and calendars. Whether‚Ä¶\ndiffer.blog\n\nWorking With More Advanced List Comprehensions and Lambda Functions\n1. Nested List Comprehensions\nTo work with nested list Comprehensions:\n\nmatrix \u003d [[j for j in range(5)] for i in range(3)]\nprint(matrix)  # Creates a 3x5 matrix\n2. Conditional List Comprehensions\nTo filter elements that meet your criteria:\n\nfiltered \u003d [x for x in range(10) if x % 2 \u003d\u003d 0]\nprint(filtered)  # Even numbers from 0 to 9\n3. List Comprehensions with Multiple Iterables\nTo merge and transform elements from multiple sources in a single dance:\n\npairs \u003d [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x !\u003d y]\nprint(pairs)  # Pairs of non-equal elements\n4. Using Lambda Functions\nTo summon anonymous functions, ephemeral and concise, for a single act of magic:\n\nsquare \u003d lambda x: x**2\nprint(square(5))  # Returns 25\n5. Lambda Functions in List Comprehensions\nTo employ lambda functions within your list comprehensions:\n\nsquared \u003d [(lambda x: x**2)(x) for x in range(5)]\nprint(squared)  # Squares of numbers from 0 to 4\n6. List Comprehensions for Flattening Lists\nTo flatten a nested list, spreading its elements into a single dimension:\n\nnested \u003d [[1, 2, 3], [4, 5], [6, 7]]\nflattened \u003d [x for sublist in nested for x in sublist]\nprint(flattened)\n7. Applying Functions to Elements\nTo apply a transformation function to each element:\n\nimport math\ntransformed \u003d [math.sqrt(x) for x in range(1, 6)]\nprint(transformed)  # Square roots of numbers from 1 to 5\n8. Using Lambda with Map and Filter\nTo map and filter lists:\n\nmapped \u003d list(map(lambda x: x**2, range(5)))\nfiltered \u003d list(filter(lambda x: x \u003e 5, mapped))\nprint(mapped)    # Squares of numbers from 0 to 4\nprint(filtered)  # Elements greater than 5\n9. List Comprehensions with Conditional Expressions\nList Comprehensions with Condidtional Expressions:\n\nconditional \u003d [x if x \u003e 2 else x**2 for x in range(5)]\nprint(conditional)  # Squares numbers less than or equal to 2, passes others unchanged\n10. Complex Transformations with Lambda\nTo conduct intricate transformations, using lambda functions:\n\ncomplex_transformation \u003d list(map(lambda x: x**2 if x % 2 \u003d\u003d 0 else x + 5, range(5)))\nprint(complex_transformation)  # Applies different transformations based on even-odd condition\nWorking With Object Oriented Programming\n1. Defining a Class\nCreating a class:\n\nclass Wizard:\n    def __init__(self, name, power):\n        self.name \u003d name\n        self.power \u003d power\n   def cast_spell(self):\n        print(f\"{self.name} casts a spell with power {self.power}!\")\n2. Creating an Instance\nTo create an instance of your class:\n\nmerlin \u003d Wizard(\"Merlin\", 100)\n3. Invoking Methods\nTo call methods on instance of class:\n\nmerlin.cast_spell()\n4. Inheritance\nSubclassing:\n\nclass ArchWizard(Wizard):\n    def __init__(self, name, power, realm):\n        super().__init__(name, power)\n        self.realm \u003d realm\n    def summon_familiar(self):\n        print(f\"{self.name} summons a familiar from the {self.realm} realm.\")\n5. Overriding Methods\nTo overide base classes:\n\nclass Sorcerer(Wizard):\n    def cast_spell(self):\n        print(f\"{self.name} casts a powerful dark spell!\")\n6. Polymorphism\nTo interact with different forms through a common interface:\n\ndef unleash_magic(wizard):\n    wizard.cast_spell()\nunleash_magic(merlin)\nunleash_magic(Sorcerer(\"Voldemort\", 90))\n7. Encapsulation\nTo use information hiding:\n\nclass Alchemist:\n    def __init__(self, secret_ingredient):\n        self.__secret \u003d secret_ingredient\n    def reveal_secret(self):\n        print(f\"The secret ingredient is {self.__secret}\")\n8. Composition\nTo assemble Objects from simpler ones:\n\nclass Spellbook:\n    def __init__(self, spells):\n        self.spells \u003d spells\nclass Mage:\n    def __init__(self, name, spellbook):\n        self.name \u003d name\n        self.spellbook \u003d spellbook\n9. Class Methods and Static Methods\nTo bind actions to the class itself or liberate them from the instance, serving broader purposes:\n\nclass Enchanter:\n    @staticmethod\n    def enchant(item):\n        print(f\"{item} is enchanted!\")\n    @classmethod\n    def summon(cls):\n        print(\"A new enchanter is summoned.\")\n10. Properties and Setters\nTo elegantly manage access to an entity‚Äôs attributes, guiding their use and protection:\n\nclass Elementalist:\n    def __init__(self, element):\n        self._element \u003d element\n    @property\n    def element(self):\n        return self._element\n   @element.setter\n    def element(self, value):\n        if value in [\"Fire\", \"Water\", \"Earth\", \"Air\"]:\n            self._element \u003d value\n        else:\n            print(\"Invalid element!\")\nWorking With Decorators\n1. Basic Decorator\nTo create a simple decorator that wraps a function:\n\ndef my_decorator(func):\n    def wrapper():\n        print(\"Something is happening before the function is called.\")\n        func()\n        print(\"Something is happening after the function is called.\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\n2. Decorator with Arguments\nTo pass arguments to the function within a decorator:\n\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"Before call\")\n        result \u003d func(*args, **kwargs)\n        print(\"After call\")\n        return result\n    return wrapper\n\n@my_decorator\ndef greet(name):\n    print(f\"Hello {name}\")\n\ngreet(\"Alice\")\n3. Using functools.wraps\nTo preserve the metadata of the original function when decorating:\n\nfrom functools import wraps\n\ndef my_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"Wrapper function\"\"\"\n        return func(*args, **kwargs)\n    return wrapper\n\n@my_decorator\ndef greet(name):\n    \"\"\"Greet someone\"\"\"\n    print(f\"Hello {name}\")\n\nprint(greet.__name__)  # Outputs: \u0027greet\u0027\nprint(greet.__doc__)   # Outputs: \u0027Greet someone\u0027\n4. Class Decorator\nTo create a decorator using a class:\n\nclass MyDecorator:\n    def __init__(self, func):\n        self.func \u003d func\n   def __call__(self, *args, **kwargs):\n        print(\"Before call\")\n        self.func(*args, **kwargs)\n        print(\"After call\")\n\n@MyDecorator\ndef greet(name):\n    print(f\"Hello {name}\")\n\ngreet(\"Alice\")\n5. Decorator with Arguments\nTo create a decorator that accepts its own arguments:\n\ndef repeat(times):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef say_hello():\n    print(\"Hello\")\n\nsay_hello()\n6. Method Decorator\nTo apply a decorator to a method within a class:\n\ndef method_decorator(func):\n    @wraps(func)\n    def wrapper(self, *args, **kwargs):\n        print(\"Method Decorator\")\n        return func(self, *args, **kwargs)\n    return wrapper\n\nclass MyClass:\n    @method_decorator\n    def greet(self, name):\n        print(f\"Hello {name}\")\n\nobj \u003d MyClass()\nobj.greet(\"Alice\")\n7. Stacking Decorators\nTo apply multiple decorators to a single function:\n\n@my_decorator\n@repeat(2)\ndef greet(name):\n    print(f\"Hello {name}\")\n\ngreet(\"Alice\")\n8. Decorator with Optional Arguments\nCreating a decorator that works with or without arguments:\n\ndef smart_decorator(arg\u003dNone):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if arg:\n                print(f\"Argument: {arg}\")\n            return func(*args, **kwargs)\n        return wrapper\n    if callable(arg):\n        return decorator(arg)\n    return decorator\n\n@smart_decorator\ndef no_args():\n    print(\"No args\")\n\n@smart_decorator(\"With args\")\ndef with_args():\n    print(\"With args\")\n\nno_args()\nwith_args()\n9. Class Method Decorator\nTo decorate a class method:\n\nclass MyClass:\n    @classmethod\n    @my_decorator\n    def class_method(cls):\n        print(\"Class method called\")\n\nMyClass.class_method()\n10. Decorator for Static Method\nTo decorate a static method:\n\nclass MyClass:\n    @staticmethod\n    @my_decorator\n    def static_method():\n        print(\"Static method called\")\n\nMyClass.static_method()\nWorking With GraphQL\n1. Setting Up a GraphQL Client\nTo work with GraphQL:\n\nfrom gql import gql, Client\nfrom gql.transport.requests import RequestsHTTPTransport\ntransport \u003d RequestsHTTPTransport(url\u003d\u0027https://your-graphql-endpoint.com/graphql\u0027)\nclient \u003d Client(transport\u003dtransport, fetch_schema_from_transport\u003dTrue)\n2. Executing a Simple Query\nExecuting a Query:\n\nquery \u003d gql(\u0027\u0027\u0027\n{\n  allWizards {\n    id\n    name\n    power\n  }\n}\n\u0027\u0027\u0027)\n\nresult \u003d client.execute(query)\nprint(result)\n3. Executing a Query with Variables\nQuery with Variables:\n\nquery \u003d gql(\u0027\u0027\u0027\nquery GetWizards($element: String!) {\n  wizards(element: $element) {\n    id\n    name\n  }\n}\n\u0027\u0027\u0027)\nparams \u003d {\"element\": \"Fire\"}\nresult \u003d client.execute(query, variable_values\u003dparams)\nprint(result)\n4. Mutations\nTo create and execute a mutation:\n\nmutation \u003d gql(\u0027\u0027\u0027\nmutation CreateWizard($name: String!, $element: String!) {\n  createWizard(name: $name, element: $element) {\n    wizard {\n      id\n      name\n    }\n  }\n}\n\u0027\u0027\u0027)\nparams \u003d {\"name\": \"Gandalf\", \"element\": \"Light\"}\nresult \u003d client.execute(mutation, variable_values\u003dparams)\nprint(result)\n5. Handling Errors\nError handling:\n\nfrom gql import gql, Client\nfrom gql.transport.exceptions import TransportQueryError\ntry:\n    result \u003d client.execute(query)\nexcept TransportQueryError as e:\n    print(f\"GraphQL Query Error: {e}\")\n6. Subscriptions\nWorking with Subscriptions:\n\nsubscription \u003d gql(\u0027\u0027\u0027\nsubscription {\n  wizardUpdated {\n    id\n    name\n    power\n  }\n}\n\u0027\u0027\u0027)\nfor result in client.subscribe(subscription):\n    print(result)\n7. Fragments\nWorking with Fragments:\n\nquery \u003d gql(\u0027\u0027\u0027\nfragment WizardDetails on Wizard {\n  name\n  power\n}\nquery {\n  allWizards {\n    ...WizardDetails\n  }\n}\n\u0027\u0027\u0027)\nresult \u003d client.execute(query)\nprint(result)\n8. Inline Fragments\nTo tailor the response based on the type of the object returned:\n\nquery \u003d gql(\u0027\u0027\u0027\n{\n  search(text: \"magic\") {\n    __typename\n    ... on Wizard {\n      name\n      power\n    }\n    ... on Spell {\n      name\n      effect\n    }\n  }\n}\n\u0027\u0027\u0027)\nresult \u003d client.execute(query)\nprint(result)\n9. Using Directives\nTo dynamically include or skip fields in your queries based on conditions:\n\nquery \u003d gql(\u0027\u0027\u0027\nquery GetWizards($withPower: Boolean!) {\n  allWizards {\n    name\n    power @include(if: $withPower)\n  }\n}\n\u0027\u0027\u0027)\nparams \u003d {\"withPower\": True}\nresult \u003d client.execute(query, variable_values\u003dparams)\nprint(result)\n10. Batching Requests\nTo combine multiple operations into a single request, reducing network overhead:\n\nfrom gql import gql, Client\nfrom gql.transport.requests import RequestsHTTPTransport\n\ntransport \u003d RequestsHTTPTransport(url\u003d\u0027https://your-graphql-endpoint.com/graphql\u0027, use_json\u003dTrue)\nclient \u003d Client(transport\u003dtransport, fetch_schema_from_transport\u003dTrue)\n\nquery1 \u003d gql(\u0027query { wizard(id: \"1\") { name } }\u0027)\nquery2 \u003d gql(\u0027query { allSpells { name } }\u0027)\n\nresults \u003d client.execute([query1, query2])\nprint(results)\nWorking With Regular Expressions\n1. Basic Pattern Matching\nTo find a match for a pattern within a string:\n\nimport re\ntext \u003d \"Search this string for patterns.\"\nmatch \u003d re.search(r\"patterns\", text)\nif match:\n    print(\"Pattern found!\")\n2. Compiling Regular Expressions\nTo compile a regular expression for repeated use:\n\npattern \u003d re.compile(r\"patterns\")\nmatch \u003d pattern.search(text)\n3. Matching at the Beginning or End\nTo check if a string starts or ends with a pattern:\n\nif re.match(r\"^Search\", text):\n    print(\"Starts with \u0027Search\u0027\")\nif re.search(r\"patterns.$\", text):\n    print(\"Ends with \u0027patterns.\u0027\")\n4. Finding All Matches\nTo find all occurrences of a pattern in a string:\n\nall_matches \u003d re.findall(r\"t\\w+\", text)  # Finds words starting with \u0027t\u0027\nprint(all_matches)\n5. Search and Replace (Substitution)\nTo replace occurrences of a pattern within a string:\n\nreplaced_text \u003d re.sub(r\"string\", \"sentence\", text)\nprint(replaced_text)\n6. Splitting a String\nTo split a string by occurrences of a pattern:\n\nwords \u003d re.split(r\"\\s+\", text)  # Split on one or more spaces\nprint(words)\n7. Escaping Special Characters\nTo match special characters literally, escape them:\n\nescaped \u003d re.search(r\"\\bfor\\b\", text)  # \\b is a word boundary\n8. Grouping and Capturing\nTo group parts of a pattern and extract their values:\n\nmatch \u003d re.search(r\"(\\w+) (\\w+)\", text)\nif match:\n    print(match.group())  # The whole match\n    print(match.group(1)) # The first group\n9. Non-Capturing Groups\nTo define groups without capturing them:\n\nmatch \u003d re.search(r\"(?:\\w+) (\\w+)\", text)\nif match:\n    print(match.group(1))  # The first (and only) group\n10. Lookahead and Lookbehind Assertions\nTo match a pattern based on what comes before or after it without including it in the result:\n\nlookahead \u003d re.search(r\"\\b\\w+(?\u003d string)\", text)  # Word before \u0027 string\u0027\nlookbehind \u003d re.search(r\"(?\u003c\u003dSearch )\\w+\", text)  # Word after \u0027Search \u0027\nif lookahead:\n    print(lookahead.group())\nif lookbehind:\n    print(lookbehind.group())\n11. Flags to Modify Pattern Matching Behavior\nTo use flags like re.IGNORECASE to change how patterns are matched:\n\ncase_insensitive \u003d re.findall(r\"search\", text, re.IGNORECASE)\nprint(case_insensitive)\n12. Using Named Groups\nTo assign names to groups and reference them by name:\n\nmatch \u003d re.search(r\"(?P\u003cfirst\u003e\\w+) (?P\u003csecond\u003e\\w+)\", text)\nif match:\n    print(match.group(\u0027first\u0027))\n    print(match.group(\u0027second\u0027))\n13. Matching Across Multiple Lines\nTo match patterns over multiple lines using the re.MULTILINE flag:\n\nmulti_line_text \u003d \"Start\\nmiddle end\"\nmatches \u003d re.findall(r\"^m\\w+\", multi_line_text, re.MULTILINE)\nprint(matches)\n14. Lazy Quantifiers\nTo match as few characters as possible using lazy quantifiers (*?, +?, ??):\n\nhtml \u003d \"\u003cbody\u003e\u003ch1\u003eTitle\u003c/h1\u003e\u003c/body\u003e\"\nmatch \u003d re.search(r\"\u003c.*?\u003e\", html)\nif match:\n    print(match.group())  # Matches \u0027\u003cbody\u003e\u0027\n15. Verbose Regular Expressions\nTo use re.VERBOSE for more readable regular expressions:\n\npattern \u003d re.compile(r\"\"\"\n    \\b      # Word boundary\n    \\w+     # One or more word characters\n    \\s      # Space\n    \"\"\", re.VERBOSE)\nmatch \u003d pattern.search(text)\nWorking With Strings\n1. Concatenating Strings\nTo join strings together:\n\ngreeting \u003d \"Hello\"\nname \u003d \"Alice\"\nmessage \u003d greeting + \", \" + name + \"!\"\nprint(message)\n2. String Formatting with str.format\nTo insert values into a string template:\n\nmessage \u003d \"{}, {}. Welcome!\".format(greeting, name)\nprint(message)\n3. Formatted String Literals (f-strings)\nTo embed expressions inside string literals (Python 3.6+):\n\nmessage \u003d f\"{greeting}, {name}. Welcome!\"\nprint(message)\n4. String Methods ‚Äî Case Conversion\nTo change the case of a string:\n\ns \u003d \"Python\"\nprint(s.upper())  # Uppercase\nprint(s.lower())  # Lowercase\nprint(s.title())  # Title Case\n5. String Methods ‚Äî strip, rstrip, lstrip\nTo remove whitespace or specific characters from the ends of a string:\n\ns \u003d \"   trim me   \"\nprint(s.strip())   # Both ends\nprint(s.rstrip())  # Right end\nprint(s.lstrip())  # Left end\n6. String Methods ‚Äî startswith, endswith\nTo check the start or end of a string for specific text:\n\ns \u003d \"filename.txt\"\nprint(s.startswith(\"file\"))  # True\nprint(s.endswith(\".txt\"))    # True\n7. String Methods ‚Äî split, join\nTo split a string into a list or join a list into a string:\n\ns \u003d \"split,this,string\"\nwords \u003d s.split(\",\")        # Split string into list\njoined \u003d \" \".join(words)    # Join list into string\nprint(words)\nprint(joined)\n8. String Methods ‚Äî replace\nTo replace parts of a string with another string:\n\ns \u003d \"Hello world\"\nnew_s \u003d s.replace(\"world\", \"Python\")\nprint(new_s)\n9. String Methods ‚Äî find, index\nTo find the position of a substring within a string:\n\ns \u003d \"look for a substring\"\nposition \u003d s.find(\"substring\")  # Returns -1 if not found\nindex \u003d s.index(\"substring\")    # Raises ValueError if not found\nprint(position)\nprint(index)\n10. String Methods ‚Äî Working with Characters\nTo process individual characters in a string:\n\ns \u003d \"characters\"\nfor char in s:\n    print(char)  # Prints each character on a new line\n11. String Methods ‚Äî isdigit, isalpha, isalnum\nTo check if a string contains only digits, alphabetic characters, or alphanumeric characters:\n\nprint(\"123\".isdigit())   # True\nprint(\"abc\".isalpha())   # True\nprint(\"abc123\".isalnum())# True\n12. String Slicing\nTo extract a substring using slicing:\n\ns \u003d \"slice me\"\nsub \u003d s[2:7]  # From 3rd to 7th character\nprint(sub)\n13. String Length with len\nTo get the length of a string:\n\ns \u003d \"length\"\nprint(len(s))  # 6\n14. Multiline Strings\nTo work with strings spanning multiple lines:\n\nmulti \u003d \"\"\"Line one\nLine two\nLine three\"\"\"\nprint(multi)\n15. Raw Strings\nTo treat backslashes as literal characters, useful for regex patterns and file paths:\n\npath \u003d r\"C:\\User\\name\\folder\"\nprint(path)\nWorking With Web Scraping\n1. Fetching Web Pages with requests\nTo retrieve the content of a web page:\n\nimport requests\n\nurl \u003d \u0027https://example.com\u0027\nresponse \u003d requests.get(url)\nhtml \u003d response.text\n2. Parsing HTML with BeautifulSoup\nTo parse HTML and extract data:\n\nfrom bs4 import BeautifulSoup\nsoup \u003d BeautifulSoup(html, \u0027html.parser\u0027)\nprint(soup.prettify())  # Pretty-print the HTML\n3. Navigating the HTML Tree\nTo find elements using tags:\n\ntitle \u003d soup.title.text  # Get the page title\nheadings \u003d soup.find_all(\u0027h1\u0027)  # List of all \u003ch1\u003e tags\n4. Using CSS Selectors\nTo select elements using CSS selectors:\n\narticles \u003d soup.select(\u0027div.article\u0027)  # All elements with class \u0027article\u0027 inside a \u003cdiv\u003e\n5. Extracting Data from Tags\nTo extract text and attributes from HTML elements:\n\nfor article in articles:\n    title \u003d article.h2.text  # Text inside the \u003ch2\u003e tag\n    link \u003d article.a[\u0027href\u0027]  # \u0027href\u0027 attribute of the \u003ca\u003e tag\n    print(title, link)\n6. Handling Relative URLs\nTo convert relative URLs to absolute URLs:\n\nfrom urllib.parse import urljoin\nabsolute_urls \u003d [urljoin(url, link) for link in relative_urls]\n7. Dealing with Pagination\nTo scrape content across multiple pages:\n\nbase_url \u003d \"https://example.com/page/\"\nfor page in range(1, 6):  # For 5 pages\n    page_url \u003d base_url + str(page)\n    response \u003d requests.get(page_url)\n    # Process each page\u0027s content\n8. Handling AJAX Requests\nTo scrape data loaded by AJAX requests:\n\n# Find the URL of the AJAX request (using browser\u0027s developer tools) and fetch it\najax_url \u003d \u0027https://example.com/ajax_endpoint\u0027\ndata \u003d requests.get(ajax_url).json()  # Assuming the response is JSON\n9. Using Regular Expressions in Web Scraping\nTo extract data using regular expressions:\n\nimport re\nemails \u003d re.findall(r\u0027\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b\u0027, html)\n10. Respecting robots.txt\nTo check robots.txt for scraping permissions:\n\nfrom urllib.robotparser import RobotFileParser\n\nrp \u003d RobotFileParser()\nrp.set_url(\u0027https://example.com/robots.txt\u0027)\nrp.read()\ncan_scrape \u003d rp.can_fetch(\u0027*\u0027, url)\n11. Using Sessions and Cookies\nTo maintain sessions and handle cookies:\n\nsession \u003d requests.Session()\nsession.get(\u0027https://example.com/login\u0027)\nsession.cookies.set(\u0027key\u0027, \u0027value\u0027)  # Set cookies, if needed\nresponse \u003d session.get(\u0027https://example.com/protected_page\u0027)\n12. Scraping with Browser Automation (selenium Library)\nTo scrape dynamic content rendered by JavaScript:\n\nfrom selenium import webdriver\nbrowser \u003d webdriver.Chrome()\nbrowser.get(\u0027https://example.com\u0027)\ncontent \u003d browser.page_source\n# Parse and extract data using BeautifulSoup, etc.\nbrowser.quit()\n13. Error Handling in Web Scraping\nTo handle errors and exceptions:\n\ntry:\n    response \u003d requests.get(url, timeout\u003d5)\n    response.raise_for_status()  # Raises an error for bad status codes\nexcept requests.exceptions.RequestException as e:\n    print(f\"Error: {e}\")\n14. Asynchronous Web Scraping\nTo scrape websites asynchronously for faster data retrieval:\n\nimport aiohttp\nimport asyncio\n\nasync def fetch(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.text()\n\nurls \u003d [\u0027https://example.com/page1\u0027, \u0027https://example.com/page2\u0027]\nloop \u003d asyncio.get_event_loop()\npages \u003d loop.run_until_complete(asyncio.gather(*(fetch(url) for url in urls)))\n15. Data Storage (CSV, Database)\nTo store scraped data in a CSV file or a database:\n\nimport csv\n\nwith open(\u0027output.csv\u0027, \u0027w\u0027, newline\u003d\u0027\u0027) as file:\n    writer \u003d csv.writer(file)\n    writer.writerow([\u0027Title\u0027, \u0027URL\u0027])\n    for article in articles:\n        writer.writerow([article[\u0027title\u0027], article[\u0027url\u0027]])\nWorking With pip (Package Management)\n1. Installing a Package\nTo summon a library from the vast repositories, incorporating its power into your environment:\n\npip install numpy\n2. Listing Installed Packages\nTo survey the compendium of libraries that reside within your realm, noting their versions and lineage:\n\npip list\n3. Upgrading a Package\nTo imbue an installed library with enhanced powers and capabilities, elevating it to its latest form:\n\npip install --upgrade numpy\n4. Uninstalling a Package\nTo uninstall a package:\n\npip uninstall numpy\n5. Searching for Packages\nSearching packages:\n\npip search \"data visualization\"\n6. Installing Specific Versions of a Package\nTo install a specific version:\n\npip install numpy\u003d\u003d1.18.5\n7. Generating a Requirements File\nRequirements file:\n\npip freeze \u003e requirements.txt\n8. Installing Packages from a Requirements File\nTo conjure a symphony of libraries in unison, each aligned with the notations in your tome of requirements:\n\npip install -r requirements.txt\n9. Using Virtual Environments\nCreate virtual Environments to manage package conflicts:\n\n# Create a virtual environment named \u0027venv\u0027\npython -m venv venv\n\n# Activate the virtual environment\n# On Windows\n.\\venv\\Scripts\\activate\n\n# On Unix or MacOS\nsource venv/bin/activate\n10. Checking Package Dependencies\nUnderstanding Dependencies:\n\npip show numpy\nWorking With Common Built-in Functions and Packages\n1. os - Operating System Interface\nTo interact with the operating system:\n\nimport os\ncurrent_directory \u003d os.getcwd()  # Get the current working directory\n2. sys - System-specific Parameters and Functions\nTo access system-specific parameters and functions:\n\nimport sys\nsys.exit()  # Exit the script\n3. datetime - Basic Date and Time Types\nTo work with dates and times:\n\nfrom datetime import datetime\nnow \u003d datetime.now()  # Current date and time\n4. math - Mathematical Functions\nTo perform mathematical operations:\n\nimport math\nresult \u003d math.sqrt(16)  # Square root\n5. random - Generate Pseudo-random Numbers\nTo generate pseudo-random numbers:\n\nimport random\nnumber \u003d random.randint(1, 10)  # Random integer between 1 and 10\n6. json - JSON Encoder and Decoder\nTo parse and generate JSON data:\n\nimport json\njson_string \u003d json.dumps({\u0027name\u0027: \u0027Alice\u0027, \u0027age\u0027: 30})  # Dictionary to JSON string\n7. re - Regular Expressions\nTo work with regular expressions:\n\nimport re\nmatch \u003d re.search(\u0027Hello\u0027, \u0027Hello, world!\u0027)  # Search for \u0027Hello\u0027 in the string\n8. urllib - URL Handling Modules\nTo work with URLs:\n\nfrom urllib.request import urlopen\ncontent \u003d urlopen(\u0027http://example.com\u0027).read()  # Fetch the content of a webpage\n9. http - HTTP Modules\nTo create HTTP servers and work with HTTP requests:\n\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nclass SimpleHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header(\u0027Content-type\u0027, \u0027text/html\u0027)\n        self.end_headers()\n        self.wfile.write(b\u0027\u003chtml\u003e\u003chead\u003e\u003ctitle\u003ePython HTTP Server\u003c/title\u003e\u003c/head\u003e\u0027)\n        self.wfile.write(b\u0027\u003cbody\u003e\u003ch1\u003eHello from a simple Python HTTP server!\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\u0027)\ndef run(server_class\u003dHTTPServer, handler_class\u003dSimpleHTTPRequestHandler):\n    server_address \u003d (\u0027\u0027, 8000)  # Serve on all addresses, port 8000\n    httpd \u003d server_class(server_address, handler_class)\n    print(\"Server starting on port 8000...\")\n    httpd.serve_forever()\nif __name__ \u003d\u003d \u0027__main__\u0027:\n    run()\n10. subprocess - Subprocess Management\nTo spawn new processes and connect to their input/output/error pipes:\n\nimport subprocess\nsubprocess.run([\u0027ls\u0027, \u0027-l\u0027])  # Run the \u0027ls -l\u0027 command\n11. socket - Low-level Networking Interface\nTo create network clients and servers:\n\nimport socket\ns \u003d socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # Create a TCP/IP socket\n12. threading - Thread-based Parallelism\nTo manage concurrent execution of code:\n\nimport threading\ndef worker():\n    print(\"Worker thread executing\")\nthread \u003d threading.Thread(target\u003dworker)\nthread.start()\n13. multiprocessing - Process-based Parallelism\nTo manage concurrent processes:\n\nfrom multiprocessing import Process\ndef worker():\n    print(\"Worker process\")\np \u003d Process(target\u003dworker)\np.start()\n14. argparse - Parser for Command-line Options, Arguments, and Sub-commands\nTo parse command-line arguments:\n\nimport argparse\nparser \u003d argparse.ArgumentParser(description\u003d\"Process some integers.\")\nargs \u003d parser.parse_args()\n15. logging - Logging Facility\nTo log messages (debug, info, warning, error, and critical):\n\nimport logging\nlogging.warning(\u0027This is a warning message\u0027)\n16. unittest - Unit Testing Framework\nTo create and run unit tests:\n\nimport unittest\nclass TestStringMethods(unittest.TestCase):\n    def test_upper(self):\n        self.assertEqual(\u0027foo\u0027.upper(), \u0027FOO\u0027)\n17. pathlib - Object-oriented Filesystem Paths\nTo work with filesystem paths in an object-oriented way:\n\nfrom pathlib import Path\np \u003d Path(\u0027.\u0027)\n18. functools - Higher-order Functions and Operations on Callable Objects\nTo use higher-order functions and operations on callable objects:\n\nfrom functools import lru_cache\n@lru_cache(maxsize\u003dNone)\ndef fib(n):\n    if n \u003c 2:\n        return n\n    return fib(n-1) + fib(n-2)\n19. collections - Container Data Types\nTo use specialized container data types (deque, Counter, OrderedDict, etc.):\n\nfrom collections import Counter\nc \u003d Counter(\u0027hello world\u0027)\n20. itertools - Functions Creating Iterators for Efficient Looping\nTo construct and use iterators for efficient looping:\n\nimport itertools\nfor combination in itertools.combinations(\u0027ABCD\u0027, 2):\n    print(combination)\n21. hashlib - Secure Hash and Message Digest Algorithms\nTo hash data:\n\nimport hashlib\nhash_object \u003d hashlib.sha256(b\u0027Hello World\u0027)\nhex_dig \u003d hash_object.hexdigest()\n22. csv - CSV File Reading and Writing\nTo read from and write to CSV files:\n\nimport csv\nwith open(\u0027file.csv\u0027, mode\u003d\u0027r\u0027) as infile:\n    reader \u003d csv.reader(infile)\n23. xml.etree.ElementTree - The ElementTree XML API\nTo parse and create XML data:\n\nimport xml.etree.ElementTree as ET\ntree \u003d ET.parse(\u0027file.xml\u0027)\nroot \u003d tree.getroot()\n24. sqlite3 - DB-API 2.0 Interface for SQLite Databases\nTo interact with SQLite databases:\n\nimport sqlite3\nconn \u003d sqlite3.connect(\u0027example.db\u0027)\n25. tkinter - GUI Toolkit\nTo create GUI applications:\n\nimport tkinter as tk\nroot \u003d tk.Tk()\n26. pickle - Python Object Serialization\nTo serialize and deserialize Python object structures:\n\nimport pickle\nserialized_obj \u003d pickle.dumps(obj)\n27. io - Core Tools for Working with Streams\nTo handle streams (file-like objects):\n\nfrom io import StringIO\nf \u003d StringIO(\"some initial text data\")\n28. time - Time Access and Conversions\nTo access time-related functions:\n\nimport time\ntime.sleep(1)  # Sleep for 1 second\n29. calendar - General Calendar-related Functions\nTo work with calendars:\n\nimport calendar\nprint(calendar.month(2023, 1))  # Print the calendar for January 2023\n30. queue - A Synchronized Queue Class\nTo manage a queue, useful in multithreaded programming:\n\nfrom queue import Queue\nq \u003d Queue()\n31. shutil - High-level File Operations\nTo perform high-level file operations, like copying and archiving:\n\nimport shutil\nshutil.copyfile(\u0027source.txt\u0027, \u0027dest.txt\u0027)\n32. glob - Unix Style Pathname Pattern Expansion\nTo find files matching a specified pattern:\n\nimport glob\nfor file in glob.glob(\"*.txt\"):\n    print(file)\n33. tempfile - Generate Temporary Files and Directories\nTo create temporary files and directories:\n\nimport tempfile\ntemp \u003d tempfile.TemporaryFile()\n34. bz2 - Support for Bzip2 Compression\nTo compress and decompress data using bzip2 compression:\n\nimport bz2\ncompressed \u003d bz2.compress(b\u0027your data here\u0027)\n35. gzip - Support for Gzip Compression\nTo compress and decompress data using gzip compression:\n\nimport gzip\nwith gzip.open(\u0027file.txt.gz\u0027, \u0027wt\u0027) as f:\n    f.write(\u0027your data here\u0027)\n36. ssl - TLS/SSL Wrapper for Socket Objects\nTo handle TLS/SSL encryption and peer authentication for network sockets:\n\nimport ssl\nssl.wrap_socket(sock)\n37. imaplib - IMAP4 Protocol Client\nTo access and manipulate mail over IMAP4:\n\nimport imaplib\nmail \u003d imaplib.IMAP4_SSL(\u0027imap.example.com\u0027)\n38. smtplib - SMTP Protocol Client\nTo send mail using the Simple Mail Transfer Protocol (SMTP):\n\nimport smtplib\nserver \u003d smtplib.SMTP(\u0027smtp.example.com\u0027, 587)\n39. email - Managing Email Messages\nTo manage email messages, including MIME and other RFC 2822-based message documents:\n\nfrom email.message import EmailMessage\nmsg \u003d EmailMessage()\n40. base64 - Base16, Base32, Base64, Base85 Data Encodings\nTo encode and decode data using Base64:\n\nimport base64\nencoded_data \u003d base64.b64encode(b\u0027data to encode\u0027)\n41. difflib - Helpers for Computing Deltas\nTo compare sequences and produce human-readable diffs:\n\nimport difflib\ndiff \u003d difflib.ndiff(\u0027one\\ntwo\\nthree\\n\u0027.splitlines(keepends\u003dTrue),\n                     \u0027ore\\ntree\\nemu\\n\u0027.splitlines(keepends\u003dTrue))\nprint(\u0027\u0027.join(diff))\n42. gettext - Multilingual Internationalization Services\nTo internationalize your Python programs:\n\nimport gettext\ngettext.install(\u0027myapp\u0027)\n43. locale - Internationalization Services\nTo access a database of culture-specific data formats:\n\nimport locale\nlocale.setlocale(locale.LC_ALL, \u0027\u0027)\n44. secrets - Generate Secure Random Numbers for Managing Secrets\nTo generate secure random numbers for managing secrets, such as tokens or passwords:\n\nimport secrets\nsecure_token \u003d secrets.token_hex(16)\n45. uuid - UUID Objects According to RFC 4122\nTo generate universally unique identifiers (UUIDs):\n\nimport uuid\nunique_id \u003d uuid.uuid4()\n46. html - HyperText Markup Language Support\nTo handle and manipulate HTML entities:\n\nimport html\nescaped \u003d html.escape(\u0027\u003ca href\u003d\"https://example.com\"\u003elink\u003c/a\u003e\u0027)\n47. ftplib - FTP Protocol Client\nTo interact with and transfer files over the FTP protocol:\n\nfrom ftplib import FTP\nftp \u003d FTP(\u0027ftp.example.com\u0027)\n48. tarfile - Read and Write Tar Archive Files\nTo work with tar archive files, allowing you to archive and compress/decompress:\n\nimport tarfile\nwith tarfile.open(\u0027sample.tar.gz\u0027, \u0027w:gz\u0027) as tar:\n    tar.add(\u0027sample.txt\u0027)\nWell, that‚Äôs all I have for now. I hope this list helps you get up to speed fast. If you like it, please share or give it a like (it helps a lot!).\n\nAdditionally, if you‚Äôd like a more in-depth and comprehensive guide to Python Development, there are two books on Amazon that I have found to be the best resources on Python out there for practical python development that I highly recommend. These books are:"
  },
  "chunkedPrompt": {
    "chunks": [{
      "text": "Working With Files\n1. Reading a File\nTo read the entire content of a file:\n\nwith open(\u0027example.txt\u0027, \u0027r\u0027) as file:\n    content \u003d file.read()\n    print(content)\n2. Writing to a File\nTo write text to a file, overwriting existing content:\n\nwith open(\u0027example.txt\u0027, \u0027w\u0027) as file:\n    file.write(\u0027Hello, Python!\u0027)\n3. Appending to a File\nTo add text to the end of an existing file:\n\nwith open(\u0027example.txt\u0027, \u0027a\u0027) as file:\n    file.write(\u0027\\nAppend this line.\u0027)\n4. Reading Lines into a List\nTo read a file line by line into a list:\n\nwith open(\u0027example.txt\u0027, \u0027r\u0027) as file:\n    lines \u003d file.readlines()\n    print(lines)\n5. Iterating Over Each Line in a File\nTo process each line in a file:\n\nwith open(\u0027example.txt\u0027, \u0027r\u0027) as file:\n    for line in file:\n        print(line.strip())\n6. Checking If a File Exists\nTo check if a file exists before performing file operations:\n\nimport os\nif os.path.exists(\u0027example.txt\u0027):\n    print(\u0027File exists.\u0027)\nelse:\n    print(\u0027File does not exist.\u0027)\n7. Writing Lists to a File\nTo write each element of a list to a new line in a file:\n\nlines \u003d [\u0027First line\u0027, \u0027Second line\u0027, \u0027Third line\u0027]\nwith open(\u0027example.txt\u0027, \u0027w\u0027) as file:\n    for line in lines:\n        file.write(f\u0027{line}\\n\u0027)\n8. Using With Blocks for Multiple Files\nTo work with multiple files simultaneously using with blocks:\n\nwith open(\u0027source.txt\u0027, \u0027r\u0027) as source, open(\u0027destination.txt\u0027, \u0027w\u0027) as destination:\n    content \u003d source.read()\n    destination.write(content)\n9. Deleting a File\nTo safely delete a file if it exists:\n\nimport os\nif os.path.exists(\u0027example.txt\u0027):\n    os.remove(\u0027example.txt\u0027)\n    print(\u0027File deleted.\u0027)\nelse:\n    print(\u0027File does not exist.\u0027)\n10. Reading and Writing Binary Files\nTo read from and write to a file in binary mode (useful for images, videos, etc.):\n\n# Reading a binary file\nwith open(\u0027image.jpg\u0027, \u0027rb\u0027) as file:\n    content \u003d file.read()\n# Writing to a binary file\nwith open(\u0027copy.jpg\u0027, \u0027wb\u0027) as file:\n    file.write(content)\nWorking With Simple HTTP APIs\n1. Basic GET Request\nTo fetch data from an API endpoint using a GET request:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/data\u0027)\ndata \u003d response.json()  # Assuming the response is JSON\nprint(data)\n2. GET Request with Query Parameters\nTo send a GET request with query parameters:\n\nimport requests\nparams \u003d {\u0027key1\u0027: \u0027value1\u0027, \u0027key2\u0027: \u0027value2\u0027}\nresponse \u003d requests.get(\u0027https://api.example.com/search\u0027, params\u003dparams)\ndata \u003d response.json()\nprint(data)\n3. Handling HTTP Errors\nTo handle possible HTTP errors gracefully:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/data\u0027)\ntry:\n    response.raise_for_status()  # Raises an HTTPError if the status is 4xx, 5xx\n    data \u003d response.json()\n    print(data)\nexcept requests.exceptions.HTTPError as err:\n    print(f\u0027HTTP Error: {err}\u0027)\n4. Setting Timeout for Requests\nTo set a timeout for API requests to avoid hanging indefinitely:\n\nimport requests\ntry:\n    response \u003d requests.get(\u0027https://api.example.com/data\u0027, timeout\u003d5)  # Timeout in seconds\n    data \u003d response.json()\n    print(data)\nexcept requests.exceptions.Timeout:\n    print(\u0027The request timed out\u0027)\n5. Using Headers in Requests\nTo include headers in your request (e.g., for authorization):\n\nimport requests\nheaders \u003d {\u0027Authorization\u0027: \u0027Bearer YOUR_ACCESS_TOKEN\u0027}\nresponse \u003d requests.get(\u0027https://api.example.com/protected\u0027, headers\u003dheaders)\ndata \u003d response.json()\nprint(data)\n6. POST Request with JSON Payload\nTo send data to an API endpoint using a POST request with a JSON payload:\n\nimport requests\npayload \u003d {\u0027key1\u0027: \u0027value1\u0027, \u0027key2\u0027: \u0027value2\u0027}\nheaders \u003d {\u0027Content-Type\u0027: \u0027application/json\u0027}\nresponse \u003d requests.post(\u0027https://api.example.com/submit\u0027, json\u003dpayload, headers\u003dheaders)\nprint(response.json())\n7. Handling Response Encoding\nTo handle the response encoding properly:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/data\u0027)\nresponse.encoding \u003d \u0027utf-8\u0027  # Set encoding to match the expected response format\ndata \u003d response.text\nprint(data)\n8. Using Sessions with Requests\nTo use a session object for making multiple requests to the same host, which can improve performance:\n\nimport requests\nwith requests.Session() as session:\n    session.headers.update({\u0027Authorization\u0027: \u0027Bearer YOUR_ACCESS_TOKEN\u0027})\n    response \u003d session.get(\u0027https://api.example.com/data\u0027)\n    print(response.json())\n9. Handling Redirects\nTo handle or disable redirects in requests:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/data\u0027, allow_redirects\u003dFalse)\nprint(response.status_code)\n10. Streaming Large Responses\nTo stream a large response to process it in chunks, rather than loading it all into memory:\n\nimport requests\nresponse \u003d requests.get(\u0027https://api.example.com/large-data\u0027, stream\u003dTrue)\nfor chunk in response.iter_content(chunk_size\u003d1024):\n    process(chunk)  # Replace \u0027process\u0027 with your actual processing function\nWorking With Lists\n1. Creating a List\nTo conjure a list into being:\n\n# A list of mystical elements\nelements \u003d [\u0027Earth\u0027, \u0027Air\u0027, \u0027Fire\u0027, \u0027Water\u0027]\n2. Appending to a List\nTo append a new element to the end of a list:\n\nelements.append(\u0027Aether\u0027)\n3. Inserting into a List\nTo insert an element at a specific position in the list:\n\n# Insert \u0027Spirit\u0027 at index 1\nelements.insert(1, \u0027Spirit\u0027)\n4. Removing from a List\nTo remove an element by value from the list:\n\nelements.remove(\u0027Earth\u0027)  # Removes the first occurrence of \u0027Earth\u0027\n5. Popping an Element from a List\nTo remove and return an element at a given index (default is the last item):\n\nlast_element \u003d elements.pop()  # Removes and returns the last element\n6. Finding the Index of an Element\nTo find the index of the first occurrence of an element:\n\nindex_of_air \u003d elements.index(\u0027Air\u0027)\n7. List Slicing\nTo slice a list, obtaining a sub-list:\n\n# Get elements from index 1 to 3\nsub_elements \u003d elements[1:4]\n8. List Comprehension\nTo create a new list by applying an expression to each element of an existing one:\n\n# Create a new list with lengths of each element\nlengths \u003d [len(element) for element in elements]\n9. Sorting a List\nTo sort a list in ascending order (in-place):\n\nelements.sort()\n10. Reversing a List\nTo reverse the elements of a list in-place:\n\nelements.reverse()\nWorking With Dictionaries\n1. Creating a Dictionary\nTo forge a new dictionary:\n\n# A tome of elements and their symbols\nelements \u003d {\u0027Hydrogen\u0027: \u0027H\u0027, \u0027Helium\u0027: \u0027He\u0027, \u0027Lithium\u0027: \u0027Li\u0027}\n2. Adding or Updating Entries\nTo add a new entry or update an existing one:\n\nelements[\u0027Carbon\u0027] \u003d \u0027C\u0027  # Adds \u0027Carbon\u0027 or updates its value to \u0027C\u0027\n3. Removing an Entry\nTo banish an entry from the dictionary:\n\ndel elements[\u0027Lithium\u0027]  # Removes the key \u0027Lithium\u0027 and its value\n4. Checking for Key Existence\nTo check if a key resides within the dictionary:\n\nif \u0027Helium\u0027 in elements:\n    print(\u0027Helium is present\u0027)\n5. Iterating Over Keys\nTo iterate over the keys in the dictionary:\n\nfor element in elements:\n    print(element)  # Prints each key\n6. Iterating Over Values\nTo traverse through the values in the dictionary:\n\nfor symbol in elements.values():\n    print(symbol)  # Prints each value\n7. Iterating Over Items\nTo journey through both keys and values together:\n\nfor element, symbol in elements.items():\n    print(f\u0027{element}: {symbol}\u0027)\n8. Dictionary Comprehension\nTo conjure a new dictionary through an incantation over an iterable:\n\n# Squares of numbers from 0 to 4\nsquares \u003d {x: x**2 for x in range(5)}\n9. Merging Dictionaries\nTo merge two or more dictionaries, forming a new alliance of their entries:\n\nalchemists \u003d {\u0027Paracelsus\u0027: \u0027Mercury\u0027}\nphilosophers \u003d {\u0027Plato\u0027: \u0027Aether\u0027}\nmerged \u003d {**alchemists, **philosophers}  # Python 3.5+\n10. Getting a Value with Default\nTo retrieve a value safely, providing a default for absent keys:\n\nelement \u003d elements.get(\u0027Neon\u0027, \u0027Unknown\u0027)  # Returns \u0027Unknown\u0027 if \u0027Neon\u0027 is not found\nWorking With The Operating System\n1. Navigating File Paths\nTo craft and dissect paths, ensuring compatibility across realms (operating systems):\n\nimport os\n# Craft a path compatible with the underlying OS\npath \u003d os.path.join(\u0027mystic\u0027, \u0027forest\u0027, \u0027artifact.txt\u0027)\n# Retrieve the tome\u0027s directory\ndirectory \u003d os.path.dirname(path)\n# Unveil the artifact\u0027s name\nartifact_name \u003d os.path.basename(path)\n2. Listing Directory Contents\nTo reveal all entities within a mystical directory:\n\nimport os\ncontents \u003d os.listdir(\u0027enchanted_grove\u0027)\nprint(contents)\n3. Creating Directories\nTo conjure new directories within the fabric of the filesystem:\n\nimport os\n# create a single directory\nos.mkdir(\u0027alchemy_lab\u0027)\n# create a hierarchy of directories\nos.makedirs(\u0027alchemy_lab/potions/elixirs\u0027)\n4. Removing Files and Directories\nTo erase files or directories, banishing their essence:\n\nimport os\n# remove a file\nos.remove(\u0027unnecessary_scroll.txt\u0027)\n# remove an empty directory\nos.rmdir(\u0027abandoned_hut\u0027)\n# remove a directory and its contents\nimport shutil\nshutil.rmtree(\u0027cursed_cavern\u0027)\n5. Executing Shell Commands\nTo invoke the shell‚Äôs ancient powers directly from Python:\n\nimport subprocess\n# Invoke the \u0027echo\u0027 incantation\nresult \u003d subprocess.run([\u0027echo\u0027, \u0027Revealing the arcane\u0027], capture_output\u003dTrue, text\u003dTrue)\nprint(result.stdout)\n6. Working with Environment Variables\nTo read and inscribe upon the ethereal environment variables:\n\nimport os\n# Read the \u0027PATH\u0027 variable\npath \u003d os.environ.get(\u0027PATH\u0027)\n# Create a new environment variable\nos.environ[\u0027MAGIC\u0027] \u003d \u0027Arcane\u0027\n7. Changing the Current Working Directory\nTo shift your presence to another directory within the filesystem:\n\nimport os\n# Traverse to the \u0027arcane_library\u0027 directory\nos.chdir(\u0027arcane_library\u0027)\n8. Path Existence and Type\nTo discern the existence of paths and their nature ‚Äî be they file or directory:\n\nimport os\n# Check if a path exists\nexists \u003d os.path.exists(\u0027mysterious_ruins\u0027)\n# Ascertain if the path is a directory\nis_directory \u003d os.path.isdir(\u0027mysterious_ruins\u0027)\n# Determine if the path is a file\nis_file \u003d os.path.isfile(\u0027ancient_manuscript.txt\u0027)\n9. Working with Temporary Files\nTo summon temporary files and directories, fleeting and ephemeral:\n\nimport tempfile\n# Create a temporary file\ntemp_file \u003d tempfile.NamedTemporaryFile(delete\u003dFalse)\nprint(temp_file.name)\n# Erect a temporary directory\ntemp_dir \u003d tempfile.TemporaryDirectory()\nprint(temp_dir.name)\n10. Getting System Information\nTo unveil information about the host system, its name, and the enchantments it supports:\n\nimport os\nimport platform\n# Discover the operating system\nos_name \u003d os.name  # \u0027posix\u0027, \u0027nt\u0027, \u0027java\u0027\n# Unearth detailed system information\nsystem_info \u003d platform.system()  # \u0027Linux\u0027, \u0027Windows\u0027, \u0027Darwin\u0027\nWorking With CLI ‚Äî STDIN, STDOUT, STDERR\n1. Reading User Input\nGetting input from STDIN:\n\nuser_input \u003d input(\"Impart your wisdom: \")\nprint(f\"You shared: {user_input}\")\n2. Printing to STDOUT\nTo print messages to the console:\n\nprint(\"Behold, the message of the ancients!\")\n3. Formatted Printing\nTo weave variables into your messages with grace and precision:\n\nname \u003d \"Merlin\"\nage \u003d 300\nprint(f\"{name}, of {age} years, speaks of forgotten lore.\")\n4. Reading Lines from STDIN\nTrim whitespaces line by line from STDIN:\n\nimport sys\nfor line in sys.stdin:\n    print(f\"Echo from the void: {line.strip()}\")\n5. Writing to STDERR\nTo send message to STDERR:\n\nimport sys\nsys.stderr.write(\"Beware! The path is fraught with peril.\\n\")\n6. Redirecting STDOUT\nTo redirect the STDOUT:\n\nimport sys\noriginal_stdout \u003d sys.stdout  # Preserve the original STDOUT\nwith open(\u0027mystic_log.txt\u0027, \u0027w\u0027) as f:\n    sys.stdout \u003d f  # Redirect STDOUT to a file\n    print(\"This message is inscribed within the mystic_log.txt.\")\nsys.stdout \u003d original_stdout  # Restore STDOUT to its original glory\n7. Redirecting STDERR\nRedirecting STDERR:\n\nimport sys\nwith open(\u0027warnings.txt\u0027, \u0027w\u0027) as f:\n    sys.stderr \u003d f  # Redirect STDERR\n    print(\"This warning is sealed within warnings.txt.\", file\u003dsys.stderr)\n8. Prompting for Passwords\nTo prompt for passwords:\n\nimport getpass\nsecret_spell \u003d getpass.getpass(\"Whisper the secret spell: \")\n9. Command Line Arguments\nWorking with and parsing command line arguments:\n\nimport sys\n# The script\u0027s name is the first argument, followed by those passed by the invoker\nscript, first_arg, second_arg \u003d sys.argv\nprint(f\"Invoked with the sacred tokens: {first_arg} and {second_arg}\")\n10. Using Argparse for Complex CLI Interactions\nAdding descriptions and options/arguments:\n\nimport argparse\nparser \u003d argparse.ArgumentParser(description\u003d\"Invoke the ancient scripts.\")\nparser.add_argument(\u0027spell\u0027, help\u003d\"The spell to cast\")\nparser.add_argument(\u0027--power\u0027, type\u003dint, help\u003d\"The power level of the spell\")\nargs \u003d parser.parse_args()\nprint(f\"Casting {args.spell} with power {args.power}\")\nWorking With Mathematical Operations and Permutations\n1. Basic Arithmetic Operations\nTo perform basic arithmetic:\n\nsum \u003d 7 + 3  # Addition\ndifference \u003d 7 - 3  # Subtraction\nproduct \u003d 7 * 3  # Multiplication\nquotient \u003d 7 / 3  # Division\nremainder \u003d 7 % 3  # Modulus (Remainder)\npower \u003d 7 ** 3  # Exponentiation\n2. Working with Complex Numbers\nTo work with complex numbers:\n\nz \u003d complex(2, 3)  # Create a complex number 2 + 3j\nreal_part \u003d z.real  # Retrieve the real part\nimaginary_part \u003d z.imag  # Retrieve the imaginary part\nconjugate \u003d z.conjugate()  # Get the conjugate\n3. Mathematical Functions\nCommon math functions:\n\nimport math\nroot \u003d math.sqrt(16)  # Square root\nlogarithm \u003d math.log(100, 10)  # Logarithm base 10 of 100\nsine \u003d math.sin(math.pi / 2)  # Sine of 90 degrees (in radians)\n4. Generating Permutations\nEasy way to generate permutations from a given set:\n\nfrom itertools import permutations\npaths \u003d permutations([1, 2, 3])  # Generate all permutations of the list [1, 2, 3]\nfor path in paths:\n    print(path)\n5. Generating Combinations\nEasy way to generate combinations:\n\nfrom itertools import combinations\ncombos \u003d combinations([1, 2, 3, 4], 2)  # Generate all 2-element combinations\nfor combo in combos:\n    print(combo)\n6. Random Number Generation\nTo get a random number:\n\nimport random\nnum \u003d random.randint(1, 100)  # Generate a random integer between 1 and 100\n7. Working with Fractions\nWhen you need to work with fractions:\n\nfrom fractions import Fraction\nf \u003d Fraction(3, 4)  # Create a fraction 3/4\nprint(f + 1)  # Add a fraction and an integer\n8. Statistical Functions\nTo get Average, Median, and Standard Deviation:\n\nimport statistics\ndata \u003d [1, 2, 3, 4, 5]\nmean \u003d statistics.mean(data)  # Average\nmedian \u003d statistics.median(data)  # Median\nstdev \u003d statistics.stdev(data)  # Standard Deviation\n9. Trigonometric Functions\nTo work with trigonometry:\n\nimport math\nangle_rad \u003d math.radians(60)  # Convert 60 degrees to radians\ncosine \u003d math.cos(angle_rad)  # Cosine of the angle\n10. Handling Infinity and NaN\nTo work with Infinity and NaN:\n\nimport math\ninfinity \u003d math.inf  # Representing infinity\nnot_a_number \u003d math.nan  # Representing a non-number (NaN)\nWorking With Databases\n1. Establishing a Connection\nTo create a connection to a Postgres Database:\n\nimport psycopg2\nconnection \u003d psycopg2.connect(\n    dbname\u003d\u0027your_database\u0027,\n    user\u003d\u0027your_username\u0027,\n    password\u003d\u0027your_password\u0027,\n    host\u003d\u0027your_host\u0027\n)\n2. Creating a Cursor\nTo create a database cursor, enabling the traversal and manipulation of records:\n\ncursor \u003d connection.cursor()\n3. Executing a Query\nSelecting data from Database:\n\ncursor.execute(\"SELECT * FROM your_table\")\n4. Fetching Query Results\nFetching data with a cursor:\n\nrecords \u003d cursor.fetchall()\nfor record in records:\n    print(record)\n5. Inserting Records\nTo insert data into tables in a database:\n\ncursor.execute(\"INSERT INTO your_table (column1, column2) VALUES (%s, %s)\", (\u0027value1\u0027, \u0027value2\u0027))\nconnection.commit()  # Seal the transaction\n6. Updating Records\nTo alter the records:\n\ncursor.execute(\"UPDATE your_table SET column1 \u003d %s WHERE column2 \u003d %s\", (\u0027new_value\u0027, \u0027condition_value\u0027))\nconnection.commit()\n7. Deleting Records\nTo delete records from the table:\n\ncursor.execute(\"DELETE FROM your_table WHERE condition_column \u003d %s\", (\u0027condition_value\u0027,))\nconnection.commit()\n8. Creating a Table\nTo create a new table, defining its structure:\n\ncursor.execute(\"\"\"\n    CREATE TABLE your_new_table (\n        id SERIAL PRIMARY KEY,\n        column1 VARCHAR(255),\n        column2 INTEGER\n    )\n\"\"\")\nconnection.commit()\n9. Dropping a Table\nTo drop a table:\n\ncursor.execute(\"DROP TABLE if exists your_table\")\nconnection.commit()\n10. Using Transactions\nTo use transactions for atomicity:\n\ntry:\n    cursor.execute(\"your first transactional query\")\n    cursor.execute(\"your second transactional query\")\n    connection.commit()  # Commit if all is well\nexcept Exception as e:\n    connection.rollback()  # Rollback in case of any issue\n    print(f\"An error occurred: {e}\")\nWorking With Async IO (Asyncrounous Programming)\n1. Defining an Asynchronous Function\nTo declare an async function:\n\nimport asyncio\nasync def fetch_data():\n    print(\"Fetching data...\")\n    await asyncio.sleep(2)  # Simulate an I/O operation\n    print(\"Data retrieved.\")\n2. Running an Asynchronous Function\nTo invoke an asynchronous function and await them:\n\nasync def main():\n    await fetch_data()\nasyncio.run(main())\n3. Awaiting Multiple Coroutines\nTo invoke multiple async functions and await all:\n\nasync def main():\n    task1 \u003d fetch_data()\n    task2 \u003d fetch_data()\n    await asyncio.gather(task1, task2)\nasyncio.run(main())\n4. Creating Tasks\nTo dispatch tasks:\n\nasync def main():\n    task1 \u003d asyncio.create_task(fetch_data())\n    task2 \u003d asyncio.create_task(fetch_data())\n    await task1\n    await task2\nasyncio.run(main())\n5. Asynchronous Iteration\nTo traverse through asynchronously, allowing time for other functions in between:\n\nasync def fetch_item(item):\n    await asyncio.sleep(1)  # Simulate an I/O operation\n    print(f\"Fetched {item}\")\nasync def main():\n    items \u003d [\u0027potion\u0027, \u0027scroll\u0027, \u0027wand\u0027]\n    for item in items:\n        await fetch_item(item)\nasyncio.run(main())\n6. Using Asynchronous Context Managers\nTo ensure resources are managed within the bounds of an asynchronous function:\n\nasync def async_context_manager():\n    print(\"Entering context\")\n    await asyncio.sleep(1)\n    print(\"Exiting context\")\nasync def main():\n    async with async_context_manager():\n        print(\"Within context\")\nasyncio.run(main())\n7. Handling Exceptions in Asynchronous Code\nTo gracefully catch and manage the errors with async functions:\n\nasync def risky_spell():\n    await asyncio.sleep(1)\n    raise ValueError(\"The spell backfired!\")\nasync def main():\n    try:\n        await risky_spell()\n    except ValueError as e:\n        print(f\"Caught an error: {e}\")\nasyncio.run(main())\n8. Asynchronous Generators\nTo create async generators, each arriving in its own time:\n\nasync def fetch_items():\n    items \u003d [\u0027crystal\u0027, \u0027amulet\u0027, \u0027dagger\u0027]\n    for item in items:\n        await asyncio.sleep(1)\n        yield item\nasync def main():\n    async for item in fetch_items():\n        print(f\"Found {item}\")\nasyncio.run(main())\n9. Using Semaphores\nTo limit the number of concurrent tasks:\n\nasync def guarded_spell(semaphore, item):\n    async with semaphore:\n        print(f\"Processing {item}\")\n        await asyncio.sleep(1)\nasync def main():\n    semaphore \u003d asyncio.Semaphore(2)  # Allow 2 concurrent tasks\n    await asyncio.gather(*(guarded_spell(semaphore, i) for i in range(5)))\nasyncio.run(main())\n10. Event Loops\nTo directly engage with the asynchronous loop, customizing the flow of execution:\n\nasync def perform_spell():\n    print(\"Casting spell...\")\n    await asyncio.sleep(1)\n    print(\"Spell cast.\")\nloop \u003d asyncio.get_event_loop()\ntry:\n    loop.run_until_complete(perform_spell())\nfinally:\n    loop.close()\nWorking With Networks, Sockets, and Network Interfaces\n1. Creating a Socket\nTo create a socket for network communication:\n\nimport socket\ns \u003d socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n2. Connecting to a Remote Server\nTo establish a link with a remote server through the socket:\n\ns.connect((\u0027example.com\u0027, 80))  # Connect to example.com on port 80\n3. Sending Data\nTo dispatch data through the network to a connected entity:\n\ns.sendall(b\u0027Hello, server\u0027)\n4. Receiving Data\nTo receive data from the network:\n\ndata \u003d s.recv(1024)  # Receive up to 1024 bytes\nprint(\u0027Received\u0027, repr(data))\n5. Closing a Socket\nTo gracefully close the socket, severing the network link:\n\ns.close()\n6. Creating a Listening Socket\nTo open a socket that listens for incoming connections:\n\nserversocket \u003d socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserversocket.bind((\u0027localhost\u0027, 8080))  # Bind to localhost on port 8080\nserversocket.listen()  # Listen for incoming connections\n7. Accepting Connections\nTo accept and establish a network link:\n\nclientsocket, address \u003d serversocket.accept()\nprint(f\"Connection from {address} has been established.\")\n8. Non-blocking Socket Operations\nTo set a socket‚Äôs mode to non-blocking:\n\ns.setblocking(False)\n9. Working with UDP Sockets\nTo create a socket for UDP, a protocol for quicker, but less reliable communication:\n\nudp_socket \u003d socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_socket.bind((\u0027localhost\u0027, 8081))  # Bind UDP socket to localhost on port 8081\n10. Enumerating Network Interfaces\nTo discover the names and addresses of the machine‚Äôs network interfaces:\n\nimport socket\nimport netifaces\nfor interface in netifaces.interfaces():\n    addr \u003d netifaces.ifaddresses(interface).get(netifaces.AF_INET)\n    if addr:\n        print(f\"Interface: {interface}, Address: {addr[0][\u0027addr\u0027]}\")\n#\n\nWorking With Pandas Library (Dataframes)\n1. Creating a DataFrame\nTo create a DataFrame with your own columns and data:\n\nimport pandas as pd\ndata \u003d {\n    \u0027Element\u0027: [\u0027Earth\u0027, \u0027Water\u0027, \u0027Fire\u0027, \u0027Air\u0027],\n    \u0027Symbol\u0027: [\u0027üúÉ\u0027, \u0027üúÑ\u0027, \u0027üúÇ\u0027, \u0027üúÅ\u0027]\n}\ndf \u003d pd.DataFrame(data)\n2. Reading Data from a CSV File\nTo read data from a CSV file, transforming it into a DataFrame:\n\ndf \u003d pd.read_csv(\u0027elements.csv\u0027)\n3. Inspecting the First Few Rows\nTo get first rows from dataframe:\n\nprint(df.head())\n4. Selecting Columns\nTo select specific columns from dataframe:\n\nsymbols \u003d df[\u0027Symbol\u0027]\n5. Filtering Rows\nTo sift through the DataFrame, selecting rows that meet your criteria:\n\nfire_elements \u003d df[df[\u0027Element\u0027] \u003d\u003d \u0027Fire\u0027]\n6. Creating New Columns\nTo create new columns in DataFrame derived from the data within:\n\ndf[\u0027Length\u0027] \u003d df[\u0027Element\u0027].apply(len)\n7. Grouping and Aggregating Data\nTo gather your data into groups and extract new data through aggregation:\n\nelement_groups \u003d df.groupby(\u0027Element\u0027).agg({\u0027Length\u0027: \u0027mean\u0027})\n8. Merging DataFrames\nTo weave together two DataFrames, joining them by a shared key:\n\ndf2 \u003d pd.DataFrame({\u0027Element\u0027: [\u0027Earth\u0027, \u0027Fire\u0027], \u0027Quality\u0027: [\u0027Solid\u0027, \u0027Plasma\u0027]})\nmerged_df \u003d pd.merge(df, df2, on\u003d\u0027Element\u0027)\n9. Handling Missing Data\nTo clean your DataFrame, filling the voids where data is absent:\n\ndf.fillna(value\u003d\u0027Unknown\u0027, inplace\u003dTrue)\n10. Pivoting and Reshaping Data\nTo transmute the shape of your DataFrame, revealing hidden patterns and structures with a pivot operation:\n\npivoted_df \u003d df.pivot(index\u003d\u0027Element\u0027, columns\u003d\u0027Symbol\u0027, values\u003d\u0027Length\u0027)\nWorking With Numpy Library (Arrays)\n1. Creating a NumPy Array\nTo create an array:\n\nimport numpy as np\narray \u003d np.array([1, 2, 3, 4, 5])\n2. Array of Zeros or Ones\nTo create an array filled with zeros:\n\nzeros \u003d np.zeros((3, 3))  # A 3x3 array of zeros\nones \u003d np.ones((2, 4))  # A 2x4 array of ones\n3. Creating a Range of Numbers\nTo create a sequence of numbers:\n\nrange_array \u003d np.arange(10, 50, 5)  # From 10 to 50, step by 5\n4. Creating a Linearly Spaced Array\nTo create a series of values, evenly spaced between two bounds:\n\nlinear_spaced \u003d np.linspace(0, 1, 5)  # 5 values from 0 to 1\n5. Reshaping an Array\nTo transmute the shape of an array, altering its dimensions:\n\nreshaped \u003d np.arange(9).reshape(3, 3)  # Reshape a 1D array into a 3x3 2D array\n6. Basic Array Operations\nTo perform elemental manipulations upon the arrays:\n\na \u003d np.array([1, 2, 3])\nb \u003d np.array([4, 5, 6])\nsum \u003d a + b  # Element-wise addition\ndifference \u003d b - a  # Element-wise subtraction\nproduct \u003d a * b  # Element-wise multiplication\n7. Matrix Multiplication\nBasic dot product Operation:\n\nresult \u003d np.dot(a.reshape(1, 3), b.reshape(3, 1))  # Dot product of a and b\n8. Accessing Array Elements\nAccessing array elements with useful syntax:\n\nelement \u003d a[2]  # Retrieve the third element of array \u0027a\u0027\nrow \u003d reshaped[1, :]  # Retrieve the second row of \u0027reshaped\u0027\n9. Boolean Indexing\nTo filter the elements of an array through the sieve of conditionals:\n\nfiltered \u003d a[a \u003e 2]  # Elements of \u0027a\u0027 greater than 2\n10. Aggregations and Statistics\nStatistical operations on np arrays:\n\nmean \u003d np.mean(a)\nmaximum \u003d np.max(a)\nsum \u003d np.sum(a)\nWorking With Matplotlib Library (Data Visualization)\n1. Creating a Basic Plot\nTo create a plot visualization:\n\nimport matplotlib.pyplot as plt\nx \u003d [1, 2, 3, 4, 5]\ny \u003d [1, 4, 9, 16, 25]\nplt.plot(x, y)\nplt.show()\n2. Adding Titles and Labels\nTo create names for axes and title your plot to give better context:\n\nplt.plot(x, y)\nplt.title(\u0027Growth Over Time\u0027)\nplt.xlabel(\u0027Time\u0027)\nplt.ylabel(\u0027Growth\u0027)\nplt.show()\n3. Creating a Scatter Plot\nCreating a scatter plot:\n\nplt.scatter(x, y)\nplt.show()\n4. Customizing Line Styles and Markers\nTo add symbols into your plot, enriching its usefulness:\n\nplt.plot(x, y, linestyle\u003d\u0027--\u0027, marker\u003d\u0027o\u0027, color\u003d\u0027b\u0027)\nplt.show()\n5. Creating Multiple Plots on the Same Axes\nCreating Multiple Plots on the Same Axes:\n\nz \u003d [2, 3, 4, 5, 6]\nplt.plot(x, y)\nplt.plot(x, z)\nplt.show()\n6. Creating Subplots\nTo create subplots:\n\nfig, ax \u003d plt.subplots(2, 1)  # 2 rows, 1 column\nax[0].plot(x, y)\nax[1].plot(x, z)\nplt.show()\n7. Creating a Histogram\nTo create a histogram:\n\ndata \u003d [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\nplt.hist(data, bins\u003d4)\nplt.show()\n8. Adding a Legend\nTo create a legend for the plot:\n\nplt.plot(x, y, label\u003d\u0027Growth\u0027)\nplt.plot(x, z, label\u003d\u0027Decay\u0027)\nplt.legend()\nplt.show()\n9. Customizing Ticks\nTo create your own marks upon the axes, defining the scale of your values:\n\nplt.plot(x, y)\nplt.xticks([1, 2, 3, 4, 5], [\u0027One\u0027, \u0027Two\u0027, \u0027Three\u0027, \u0027Four\u0027, \u0027Five\u0027])\nplt.yticks([0, 5, 10, 15, 20, 25], [\u00270\u0027, \u00275\u0027, \u002710\u0027, \u002715\u0027, \u002720\u0027, \u002725+\u0027])\nplt.show()\n10. Saving Figures\nTo save the plot as a .png:\n\nplt.plot(x, y)\nplt.savefig(\u0027growth_over_time.png\u0027)\nWorking With Scikit-Learn Library (Machine Learning)\n1. Loading a Dataset\nTo work with datasets for your ML experiments\n\nfrom sklearn import datasets\niris \u003d datasets.load_iris()\nX, y \u003d iris.data, iris.target\n2. Splitting Data into Training and Test Sets\nTo divide your data, dedicating portions to training and evaluation:\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test \u003d train_test_split(X, y, test_size\u003d0.2)\n3. Training a Model\nTraining a ML Model using RandomForestClassifier:\n\nfrom sklearn.ensemble import RandomForestClassifier\nmodel \u003d RandomForestClassifier()\nmodel.fit(X_train, y_train)\n4. Making Predictions\nTo access the model predictions:\n\npredictions \u003d model.predict(X_test)\n5. Evaluating Model Performance\nTo evaluate your model, measuring its accuracy in prediction:\n\nfrom sklearn.metrics import accuracy_score\naccuracy \u003d accuracy_score(y_test, predictions)\nprint(f\"Model accuracy: {accuracy}\")\n6. Using Cross-Validation\nTo use Cross-Validation:\n\nfrom sklearn.model_selection import cross_val_score\nscores \u003d cross_val_score(model, X, y, cv\u003d5)\nprint(f\"Cross-validation scores: {scores}\")\n7. Feature Scaling\nTo create the appropriate scales of your features, allowing the model to learn more effectively:\n\nfrom sklearn.preprocessing import StandardScaler\nscaler \u003d StandardScaler()\nX_train_scaled \u003d scaler.fit_transform(X_train)\nX_test_scaled \u003d scaler.transform(X_test)\n8. Parameter Tuning with Grid Search\nTo refine your model‚Äôs parameters, seeking the optimal combination:\n\nfrom sklearn.model_selection import GridSearchCV\nparam_grid \u003d {\u0027n_estimators\u0027: [10, 50, 100], \u0027max_depth\u0027: [None, 10, 20]}\ngrid_search \u003d GridSearchCV(model, param_grid, cv\u003d5)\ngrid_search.fit(X_train, y_train)\n9. Pipeline Creation\nTo streamline your data processing and modeling steps, crafting a seamless flow:\n\nfrom sklearn.pipeline import Pipeline\npipeline \u003d Pipeline([\n    (\u0027scaler\u0027, StandardScaler()),\n    (\u0027classifier\u0027, RandomForestClassifier())\n])\npipeline.fit(X_train, y_train)\n10. Saving and Loading a Model\nTo preserve your model:\n\nimport joblib\n# Saving the model\njoblib.dump(model, \u0027model.joblib\u0027)\n# Loading the model\nloaded_model \u003d joblib.load(\u0027model.joblib\u0027)\nWorking With Plotly Library (Interactive Data Visualization)\n1. Creating a Basic Line Chart\nTo create a line chart:\n\nimport plotly.graph_objs as go\nimport plotly.io as pio\nx \u003d [1, 2, 3, 4, 5]\ny \u003d [1, 4, 9, 16, 25]\nfig \u003d go.Figure(data\u003dgo.Scatter(x\u003dx, y\u003dy, mode\u003d\u0027lines\u0027))\npio.show(fig)\n2. Creating a Scatter Plot\nTo create a scatter plot:\n\nfig \u003d go.Figure(data\u003dgo.Scatter(x\u003dx, y\u003dy, mode\u003d\u0027markers\u0027))\npio.show(fig)\n3. Creating a Bar Chart\nTo Create a Bar Chart:\n\ncategories \u003d [\u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027]\nvalues \u003d [10, 20, 15, 30, 25]\nfig \u003d go.Figure(data\u003dgo.Bar(x\u003dcategories, y\u003dvalues))\npio.show(fig)\n4. Creating a Pie Chart\nTo create a Pie Chart:\n\nlabels \u003d [\u0027Earth\u0027, \u0027Water\u0027, \u0027Fire\u0027, \u0027Air\u0027]\nsizes \u003d [25, 35, 20, 20]\nfig \u003d go.Figure(data\u003dgo.Pie(labels\u003dlabels, values\u003dsizes))\npio.show(fig)\n5. Creating a Histogram\nTo create a Histogram:\n\ndata \u003d [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\nfig \u003d go.Figure(data\u003dgo.Histogram(x\u003ddata))\npio.show(fig)\n6. Creating Box Plots\nTo create a Box Plot:\n\ndata \u003d [1, 2, 2, 3, 4, 4, 4, 5, 5, 6]\nfig \u003d go.Figure(data\u003dgo.Box(y\u003ddata))\npio.show(fig)\n7. Creating Heatmaps\nTo create a heatmap:\n\nimport numpy as np\nz \u003d np.random.rand(10, 10)  # Generate random data\nfig \u003d go.Figure(data\u003dgo.Heatmap(z\u003dz))\npio.show(fig)\n8. Creating 3D Surface Plots\nTo create a 3D Surface Plot:\n\nz \u003d np.random.rand(20, 20)  # Generate random data\nfig \u003d go.Figure(data\u003dgo.Surface(z\u003dz))\npio.show(fig)\n9. Creating Subplots\nTo create a subplot:\n\nfrom plotly.subplots import make_subplots\nfig \u003d make_subplots(rows\u003d1, cols\u003d2)\nfig.add_trace(go.Scatter(x\u003dx, y\u003dy, mode\u003d\u0027lines\u0027), row\u003d1, col\u003d1)\nfig.add_trace(go.Bar(x\u003dcategories, y\u003dvalues), row\u003d1, col\u003d2)\npio.show(fig)\n10. Creating Interactive Time Series\nTo work with Time Series:\n\nimport pandas as pd\ndates \u003d pd.date_range(\u002720230101\u0027, periods\u003d5)\nvalues \u003d [10, 11, 12, 13, 14]\nfig \u003d go.Figure(data\u003dgo.Scatter(x\u003ddates, y\u003dvalues, mode\u003d\u0027lines+markers\u0027))\npio.show(fig)\nWorking With Dates and Times\n1. Getting the Current Date and Time\nTo get the current data and time:\n\nfrom datetime import datetime\nnow \u003d datetime.now()\nprint(f\"Current date and time: {now}\")\n2. Creating Specific Date and Time\nTo conjure a moment from the past or future, crafting it with precision:\n\nspecific_time \u003d datetime(2023, 1, 1, 12, 30)\nprint(f\"Specific date and time: {specific_time}\")\n3. Formatting Dates and Times\nFormatting Dates and Times:\n\nformatted \u003d now.strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(f\"Formatted date and time: {formatted}\")\n4. Parsing Dates and Times from Strings\nParsing Dates and Times from Strings:\n\ndate_string \u003d \"2023-01-01 15:00:00\"\nparsed_date \u003d datetime.strptime(date_string, \"%Y-%m-%d %H:%M:%S\")\nprint(f\"Parsed date and time: {parsed_date}\")\n5. Working with Time Deltas\nTo traverse the distances between moments, leaping forward or backward through time:\n\nfrom datetime import timedelta\ndelta \u003d timedelta(days\u003d7)\nfuture_date \u003d now + delta\nprint(f\"Date after 7 days: {future_date}\")\n6. Comparing Dates and Times\nDate and Times comparisons:\n\nif specific_time \u003e now:\n    print(\"Specific time is in the future.\")\nelse:\n    print(\"Specific time has passed.\")\n7. Extracting Components from a Date/Time\nTo extract dates year, month, day, and more:\n\nyear \u003d now.year\nmonth \u003d now.month\nday \u003d now.day\nhour \u003d now.hour\nminute \u003d now.minute\nsecond \u003d now.second\nprint(f\"Year: {year}, Month: {month}, Day: {day}, Hour: {hour}, Minute: {minute}, Second: {second}\")\n8. Working with Time Zones\nTo work with time zones honoring the local time:\n\nfrom datetime import timezone, timedelta\nutc_time \u003d datetime.now(timezone.utc)\nprint(f\"Current UTC time: {utc_time}\")\n# Adjusting to a specific timezone (e.g., EST)\nest_time \u003d utc_time - timedelta(hours\u003d5)\nprint(f\"Current EST time: {est_time}\")\n9. Getting the Weekday\nTo identify the day of the week:\n\nweekday \u003d now.strftime(\"%A\")\nprint(f\"Today is: {weekday}\")\n10. Working with Unix Timestamps\nTo converse with the ancient epochs, translating their count from the dawn of Unix:\n\ntimestamp \u003d datetime.timestamp(now)\nprint(f\"Current timestamp: {timestamp}\")\n# Converting a timestamp back to a datetime\ndate_from_timestamp \u003d datetime.fromtimestamp(timestamp)\nprint(f\"Date from timestamp: {date_from_timestamp}\")\nAlso, check out the calendar module in Python:\n\nFrom Dates to Holidays: Demystifying the \"calendar\" Module in Python\nYour subtitle here The calendar module in Python is a versatile tool for handling dates, times, and calendars. Whether‚Ä¶\ndiffer.blog\n\nWorking With More Advanced List Comprehensions and Lambda Functions\n1. Nested List Comprehensions\nTo work with nested list Comprehensions:\n\nmatrix \u003d [[j for j in range(5)] for i in range(3)]\nprint(matrix)  # Creates a 3x5 matrix\n2. Conditional List Comprehensions\nTo filter elements that meet your criteria:\n\nfiltered \u003d [x for x in range(10) if x % 2 \u003d\u003d 0]\nprint(filtered)  # Even numbers from 0 to 9\n3. List Comprehensions with Multiple Iterables\nTo merge and transform elements from multiple sources in a single dance:\n\npairs \u003d [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x !\u003d y]\nprint(pairs)  # Pairs of non-equal elements\n4. Using Lambda Functions\nTo summon anonymous functions, ephemeral and concise, for a single act of magic:\n\nsquare \u003d lambda x: x**2\nprint(square(5))  # Returns 25\n5. Lambda Functions in List Comprehensions\nTo employ lambda functions within your list comprehensions:\n\nsquared \u003d [(lambda x: x**2)(x) for x in range(5)]\nprint(squared)  # Squares of numbers from 0 to 4\n6. List Comprehensions for Flattening Lists\nTo flatten a nested list, spreading its elements into a single dimension:\n\nnested \u003d [[1, 2, 3], [4, 5], [6, 7]]\nflattened \u003d [x for sublist in nested for x in sublist]\nprint(flattened)\n7. Applying Functions to Elements\nTo apply a transformation function to each element:\n\nimport math\ntransformed \u003d [math.sqrt(x) for x in range(1, 6)]\nprint(transformed)  # Square roots of numbers from 1 to 5\n8. Using Lambda with Map and Filter\nTo map and filter lists:\n\nmapped \u003d list(map(lambda x: x**2, range(5)))\nfiltered \u003d list(filter(lambda x: x \u003e 5, mapped))\nprint(mapped)    # Squares of numbers from 0 to 4\nprint(filtered)  # Elements greater than 5\n9. List Comprehensions with Conditional Expressions\nList Comprehensions with Condidtional Expressions:\n\nconditional \u003d [x if x \u003e 2 else x**2 for x in range(5)]\nprint(conditional)  # Squares numbers less than or equal to 2, passes others unchanged\n10. Complex Transformations with Lambda\nTo conduct intricate transformations, using lambda functions:\n\ncomplex_transformation \u003d list(map(lambda x: x**2 if x % 2 \u003d\u003d 0 else x + 5, range(5)))\nprint(complex_transformation)  # Applies different transformations based on even-odd condition\nWorking With Object Oriented Programming\n1. Defining a Class\nCreating a class:\n\nclass Wizard:\n    def __init__(self, name, power):\n        self.name \u003d name\n        self.power \u003d power\n   def cast_spell(self):\n        print(f\"{self.name} casts a spell with power {self.power}!\")\n2. Creating an Instance\nTo create an instance of your class:\n\nmerlin \u003d Wizard(\"Merlin\", 100)\n3. Invoking Methods\nTo call methods on instance of class:\n\nmerlin.cast_spell()\n4. Inheritance\nSubclassing:\n\nclass ArchWizard(Wizard):\n    def __init__(self, name, power, realm):\n        super().__init__(name, power)\n        self.realm \u003d realm\n    def summon_familiar(self):\n        print(f\"{self.name} summons a familiar from the {self.realm} realm.\")\n5. Overriding Methods\nTo overide base classes:\n\nclass Sorcerer(Wizard):\n    def cast_spell(self):\n        print(f\"{self.name} casts a powerful dark spell!\")\n6. Polymorphism\nTo interact with different forms through a common interface:\n\ndef unleash_magic(wizard):\n    wizard.cast_spell()\nunleash_magic(merlin)\nunleash_magic(Sorcerer(\"Voldemort\", 90))\n7. Encapsulation\nTo use information hiding:\n\nclass Alchemist:\n    def __init__(self, secret_ingredient):\n        self.__secret \u003d secret_ingredient\n    def reveal_secret(self):\n        print(f\"The secret ingredient is {self.__secret}\")\n8. Composition\nTo assemble Objects from simpler ones:\n\nclass Spellbook:\n    def __init__(self, spells):\n        self.spells \u003d spells\nclass Mage:\n    def __init__(self, name, spellbook):\n        self.name \u003d name\n        self.spellbook \u003d spellbook\n9. Class Methods and Static Methods\nTo bind actions to the class itself or liberate them from the instance, serving broader purposes:\n\nclass Enchanter:\n    @staticmethod\n    def enchant(item):\n        print(f\"{item} is enchanted!\")\n    @classmethod\n    def summon(cls):\n        print(\"A new enchanter is summoned.\")\n10. Properties and Setters\nTo elegantly manage access to an entity‚Äôs attributes, guiding their use and protection:\n\nclass Elementalist:\n    def __init__(self, element):\n        self._element \u003d element\n    @property\n    def element(self):\n        return self._element\n   @element.setter\n    def element(self, value):\n        if value in [\"Fire\", \"Water\", \"Earth\", \"Air\"]:\n            self._element \u003d value\n        else:\n            print(\"Invalid element!\")\nWorking With Decorators\n1. Basic Decorator\nTo create a simple decorator that wraps a function:\n\ndef my_decorator(func):\n    def wrapper():\n        print(\"Something is happening before the function is called.\")\n        func()\n        print(\"Something is happening after the function is called.\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\n2. Decorator with Arguments\nTo pass arguments to the function within a decorator:\n\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"Before call\")\n        result \u003d func(*args, **kwargs)\n        print(\"After call\")\n        return result\n    return wrapper\n\n@my_decorator\ndef greet(name):\n    print(f\"Hello {name}\")\n\ngreet(\"Alice\")\n3. Using functools.wraps\nTo preserve the metadata of the original function when decorating:\n\nfrom functools import wraps\n\ndef my_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"Wrapper function\"\"\"\n        return func(*args, **kwargs)\n    return wrapper\n\n@my_decorator\ndef greet(name):\n    \"\"\"Greet someone\"\"\"\n    print(f\"Hello {name}\")\n\nprint(greet.__name__)  # Outputs: \u0027greet\u0027\nprint(greet.__doc__)   # Outputs: \u0027Greet someone\u0027\n4. Class Decorator\nTo create a decorator using a class:\n\nclass MyDecorator:\n    def __init__(self, func):\n        self.func \u003d func\n   def __call__(self, *args, **kwargs):\n        print(\"Before call\")\n        self.func(*args, **kwargs)\n        print(\"After call\")\n\n@MyDecorator\ndef greet(name):\n    print(f\"Hello {name}\")\n\ngreet(\"Alice\")\n5. Decorator with Arguments\nTo create a decorator that accepts its own arguments:\n\ndef repeat(times):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef say_hello():\n    print(\"Hello\")\n\nsay_hello()\n6. Method Decorator\nTo apply a decorator to a method within a class:\n\ndef method_decorator(func):\n    @wraps(func)\n    def wrapper(self, *args, **kwargs):\n        print(\"Method Decorator\")\n        return func(self, *args, **kwargs)\n    return wrapper\n\nclass MyClass:\n    @method_decorator\n    def greet(self, name):\n        print(f\"Hello {name}\")\n\nobj \u003d MyClass()\nobj.greet(\"Alice\")\n7. Stacking Decorators\nTo apply multiple decorators to a single function:\n\n@my_decorator\n@repeat(2)\ndef greet(name):\n    print(f\"Hello {name}\")\n\ngreet(\"Alice\")\n8. Decorator with Optional Arguments\nCreating a decorator that works with or without arguments:\n\ndef smart_decorator(arg\u003dNone):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if arg:\n                print(f\"Argument: {arg}\")\n            return func(*args, **kwargs)\n        return wrapper\n    if callable(arg):\n        return decorator(arg)\n    return decorator\n\n@smart_decorator\ndef no_args():\n    print(\"No args\")\n\n@smart_decorator(\"With args\")\ndef with_args():\n    print(\"With args\")\n\nno_args()\nwith_args()\n9. Class Method Decorator\nTo decorate a class method:\n\nclass MyClass:\n    @classmethod\n    @my_decorator\n    def class_method(cls):\n        print(\"Class method called\")\n\nMyClass.class_method()\n10. Decorator for Static Method\nTo decorate a static method:\n\nclass MyClass:\n    @staticmethod\n    @my_decorator\n    def static_method():\n        print(\"Static method called\")\n\nMyClass.static_method()\nWorking With GraphQL\n1. Setting Up a GraphQL Client\nTo work with GraphQL:\n\nfrom gql import gql, Client\nfrom gql.transport.requests import RequestsHTTPTransport\ntransport \u003d RequestsHTTPTransport(url\u003d\u0027https://your-graphql-endpoint.com/graphql\u0027)\nclient \u003d Client(transport\u003dtransport, fetch_schema_from_transport\u003dTrue)\n2. Executing a Simple Query\nExecuting a Query:\n\nquery \u003d gql(\u0027\u0027\u0027\n{\n  allWizards {\n    id\n    name\n    power\n  }\n}\n\u0027\u0027\u0027)\n\nresult \u003d client.execute(query)\nprint(result)\n3. Executing a Query with Variables\nQuery with Variables:\n\nquery \u003d gql(\u0027\u0027\u0027\nquery GetWizards($element: String!) {\n  wizards(element: $element) {\n    id\n    name\n  }\n}\n\u0027\u0027\u0027)\nparams \u003d {\"element\": \"Fire\"}\nresult \u003d client.execute(query, variable_values\u003dparams)\nprint(result)\n4. Mutations\nTo create and execute a mutation:\n\nmutation \u003d gql(\u0027\u0027\u0027\nmutation CreateWizard($name: String!, $element: String!) {\n  createWizard(name: $name, element: $element) {\n    wizard {\n      id\n      name\n    }\n  }\n}\n\u0027\u0027\u0027)\nparams \u003d {\"name\": \"Gandalf\", \"element\": \"Light\"}\nresult \u003d client.execute(mutation, variable_values\u003dparams)\nprint(result)\n5. Handling Errors\nError handling:\n\nfrom gql import gql, Client\nfrom gql.transport.exceptions import TransportQueryError\ntry:\n    result \u003d client.execute(query)\nexcept TransportQueryError as e:\n    print(f\"GraphQL Query Error: {e}\")\n6. Subscriptions\nWorking with Subscriptions:\n\nsubscription \u003d gql(\u0027\u0027\u0027\nsubscription {\n  wizardUpdated {\n    id\n    name\n    power\n  }\n}\n\u0027\u0027\u0027)\nfor result in client.subscribe(subscription):\n    print(result)\n7. Fragments\nWorking with Fragments:\n\nquery \u003d gql(\u0027\u0027\u0027\nfragment WizardDetails on Wizard {\n  name\n  power\n}\nquery {\n  allWizards {\n    ...WizardDetails\n  }\n}\n\u0027\u0027\u0027)\nresult \u003d client.execute(query)\nprint(result)\n8. Inline Fragments\nTo tailor the response based on the type of the object returned:\n\nquery \u003d gql(\u0027\u0027\u0027\n{\n  search(text: \"magic\") {\n    __typename\n    ... on Wizard {\n      name\n      power\n    }\n    ... on Spell {\n      name\n      effect\n    }\n  }\n}\n\u0027\u0027\u0027)\nresult \u003d client.execute(query)\nprint(result)\n9. Using Directives\nTo dynamically include or skip fields in your queries based on conditions:\n\nquery \u003d gql(\u0027\u0027\u0027\nquery GetWizards($withPower: Boolean!) {\n  allWizards {\n    name\n    power @include(if: $withPower)\n  }\n}\n\u0027\u0027\u0027)\nparams \u003d {\"withPower\": True}\nresult \u003d client.execute(query, variable_values\u003dparams)\nprint(result)\n10. Batching Requests\nTo combine multiple operations into a single request, reducing network overhead:\n\nfrom gql import gql, Client\nfrom gql.transport.requests import RequestsHTTPTransport\n\ntransport \u003d RequestsHTTPTransport(url\u003d\u0027https://your-graphql-endpoint.com/graphql\u0027, use_json\u003dTrue)\nclient \u003d Client(transport\u003dtransport, fetch_schema_from_transport\u003dTrue)\n\nquery1 \u003d gql(\u0027query { wizard(id: \"1\") { name } }\u0027)\nquery2 \u003d gql(\u0027query { allSpells { name } }\u0027)\n\nresults \u003d client.execute([query1, query2])\nprint(results)\nWorking With Regular Expressions\n1. Basic Pattern Matching\nTo find a match for a pattern within a string:\n\nimport re\ntext \u003d \"Search this string for patterns.\"\nmatch \u003d re.search(r\"patterns\", text)\nif match:\n    print(\"Pattern found!\")\n2. Compiling Regular Expressions\nTo compile a regular expression for repeated use:\n\npattern \u003d re.compile(r\"patterns\")\nmatch \u003d pattern.search(text)\n3. Matching at the Beginning or End\nTo check if a string starts or ends with a pattern:\n\nif re.match(r\"^Search\", text):\n    print(\"Starts with \u0027Search\u0027\")\nif re.search(r\"patterns.$\", text):\n    print(\"Ends with \u0027patterns.\u0027\")\n4. Finding All Matches\nTo find all occurrences of a pattern in a string:\n\nall_matches \u003d re.findall(r\"t\\w+\", text)  # Finds words starting with \u0027t\u0027\nprint(all_matches)\n5. Search and Replace (Substitution)\nTo replace occurrences of a pattern within a string:\n\nreplaced_text \u003d re.sub(r\"string\", \"sentence\", text)\nprint(replaced_text)\n6. Splitting a String\nTo split a string by occurrences of a pattern:\n\nwords \u003d re.split(r\"\\s+\", text)  # Split on one or more spaces\nprint(words)\n7. Escaping Special Characters\nTo match special characters literally, escape them:\n\nescaped \u003d re.search(r\"\\bfor\\b\", text)  # \\b is a word boundary\n8. Grouping and Capturing\nTo group parts of a pattern and extract their values:\n\nmatch \u003d re.search(r\"(\\w+) (\\w+)\", text)\nif match:\n    print(match.group())  # The whole match\n    print(match.group(1)) # The first group\n9. Non-Capturing Groups\nTo define groups without capturing them:\n\nmatch \u003d re.search(r\"(?:\\w+) (\\w+)\", text)\nif match:\n    print(match.group(1))  # The first (and only) group\n10. Lookahead and Lookbehind Assertions\nTo match a pattern based on what comes before or after it without including it in the result:\n\nlookahead \u003d re.search(r\"\\b\\w+(?\u003d string)\", text)  # Word before \u0027 string\u0027\nlookbehind \u003d re.search(r\"(?\u003c\u003dSearch )\\w+\", text)  # Word after \u0027Search \u0027\nif lookahead:\n    print(lookahead.group())\nif lookbehind:\n    print(lookbehind.group())\n11. Flags to Modify Pattern Matching Behavior\nTo use flags like re.IGNORECASE to change how patterns are matched:\n\ncase_insensitive \u003d re.findall(r\"search\", text, re.IGNORECASE)\nprint(case_insensitive)\n12. Using Named Groups\nTo assign names to groups and reference them by name:\n\nmatch \u003d re.search(r\"(?P\u003cfirst\u003e\\w+) (?P\u003csecond\u003e\\w+)\", text)\nif match:\n    print(match.group(\u0027first\u0027))\n    print(match.group(\u0027second\u0027))\n13. Matching Across Multiple Lines\nTo match patterns over multiple lines using the re.MULTILINE flag:\n\nmulti_line_text \u003d \"Start\\nmiddle end\"\nmatches \u003d re.findall(r\"^m\\w+\", multi_line_text, re.MULTILINE)\nprint(matches)\n14. Lazy Quantifiers\nTo match as few characters as possible using lazy quantifiers (*?, +?, ??):\n\nhtml \u003d \"\u003cbody\u003e\u003ch1\u003eTitle\u003c/h1\u003e\u003c/body\u003e\"\nmatch \u003d re.search(r\"\u003c.*?\u003e\", html)\nif match:\n    print(match.group())  # Matches \u0027\u003cbody\u003e\u0027\n15. Verbose Regular Expressions\nTo use re.VERBOSE for more readable regular expressions:\n\npattern \u003d re.compile(r\"\"\"\n    \\b      # Word boundary\n    \\w+     # One or more word characters\n    \\s      # Space\n    \"\"\", re.VERBOSE)\nmatch \u003d pattern.search(text)\nWorking With Strings\n1. Concatenating Strings\nTo join strings together:\n\ngreeting \u003d \"Hello\"\nname \u003d \"Alice\"\nmessage \u003d greeting + \", \" + name + \"!\"\nprint(message)\n2. String Formatting with str.format\nTo insert values into a string template:\n\nmessage \u003d \"{}, {}. Welcome!\".format(greeting, name)\nprint(message)\n3. Formatted String Literals (f-strings)\nTo embed expressions inside string literals (Python 3.6+):\n\nmessage \u003d f\"{greeting}, {name}. Welcome!\"\nprint(message)\n4. String Methods ‚Äî Case Conversion\nTo change the case of a string:\n\ns \u003d \"Python\"\nprint(s.upper())  # Uppercase\nprint(s.lower())  # Lowercase\nprint(s.title())  # Title Case\n5. String Methods ‚Äî strip, rstrip, lstrip\nTo remove whitespace or specific characters from the ends of a string:\n\ns \u003d \"   trim me   \"\nprint(s.strip())   # Both ends\nprint(s.rstrip())  # Right end\nprint(s.lstrip())  # Left end\n6. String Methods ‚Äî startswith, endswith\nTo check the start or end of a string for specific text:\n\ns \u003d \"filename.txt\"\nprint(s.startswith(\"file\"))  # True\nprint(s.endswith(\".txt\"))    # True\n7. String Methods ‚Äî split, join\nTo split a string into a list or join a list into a string:\n\ns \u003d \"split,this,string\"\nwords \u003d s.split(\",\")        # Split string into list\njoined \u003d \" \".join(words)    # Join list into string\nprint(words)\nprint(joined)\n8. String Methods ‚Äî replace\nTo replace parts of a string with another string:\n\ns \u003d \"Hello world\"\nnew_s \u003d s.replace(\"world\", \"Python\")\nprint(new_s)\n9. String Methods ‚Äî find, index\nTo find the position of a substring within a string:\n\ns \u003d \"look for a substring\"\nposition \u003d s.find(\"substring\")  # Returns -1 if not found\nindex \u003d s.index(\"substring\")    # Raises ValueError if not found\nprint(position)\nprint(index)\n10. String Methods ‚Äî Working with Characters\nTo process individual characters in a string:\n\ns \u003d \"characters\"\nfor char in s:\n    print(char)  # Prints each character on a new line\n11. String Methods ‚Äî isdigit, isalpha, isalnum\nTo check if a string contains only digits, alphabetic characters, or alphanumeric characters:\n\nprint(\"123\".isdigit())   # True\nprint(\"abc\".isalpha())   # True\nprint(\"abc123\".isalnum())# True\n12. String Slicing\nTo extract a substring using slicing:\n\ns \u003d \"slice me\"\nsub \u003d s[2:7]  # From 3rd to 7th character\nprint(sub)\n13. String Length with len\nTo get the length of a string:\n\ns \u003d \"length\"\nprint(len(s))  # 6\n14. Multiline Strings\nTo work with strings spanning multiple lines:\n\nmulti \u003d \"\"\"Line one\nLine two\nLine three\"\"\"\nprint(multi)\n15. Raw Strings\nTo treat backslashes as literal characters, useful for regex patterns and file paths:\n\npath \u003d r\"C:\\User\\name\\folder\"\nprint(path)\nWorking With Web Scraping\n1. Fetching Web Pages with requests\nTo retrieve the content of a web page:\n\nimport requests\n\nurl \u003d \u0027https://example.com\u0027\nresponse \u003d requests.get(url)\nhtml \u003d response.text\n2. Parsing HTML with BeautifulSoup\nTo parse HTML and extract data:\n\nfrom bs4 import BeautifulSoup\nsoup \u003d BeautifulSoup(html, \u0027html.parser\u0027)\nprint(soup.prettify())  # Pretty-print the HTML\n3. Navigating the HTML Tree\nTo find elements using tags:\n\ntitle \u003d soup.title.text  # Get the page title\nheadings \u003d soup.find_all(\u0027h1\u0027)  # List of all \u003ch1\u003e tags\n4. Using CSS Selectors\nTo select elements using CSS selectors:\n\narticles \u003d soup.select(\u0027div.article\u0027)  # All elements with class \u0027article\u0027 inside a \u003cdiv\u003e\n5. Extracting Data from Tags\nTo extract text and attributes from HTML elements:\n\nfor article in articles:\n    title \u003d article.h2.text  # Text inside the \u003ch2\u003e tag\n    link \u003d article.a[\u0027href\u0027]  # \u0027href\u0027 attribute of the \u003ca\u003e tag\n    print(title, link)\n6. Handling Relative URLs\nTo convert relative URLs to absolute URLs:\n\nfrom urllib.parse import urljoin\nabsolute_urls \u003d [urljoin(url, link) for link in relative_urls]\n7. Dealing with Pagination\nTo scrape content across multiple pages:\n\nbase_url \u003d \"https://example.com/page/\"\nfor page in range(1, 6):  # For 5 pages\n    page_url \u003d base_url + str(page)\n    response \u003d requests.get(page_url)\n    # Process each page\u0027s content\n8. Handling AJAX Requests\nTo scrape data loaded by AJAX requests:\n\n# Find the URL of the AJAX request (using browser\u0027s developer tools) and fetch it\najax_url \u003d \u0027https://example.com/ajax_endpoint\u0027\ndata \u003d requests.get(ajax_url).json()  # Assuming the response is JSON\n9. Using Regular Expressions in Web Scraping\nTo extract data using regular expressions:\n\nimport re\nemails \u003d re.findall(r\u0027\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b\u0027, html)\n10. Respecting robots.txt\nTo check robots.txt for scraping permissions:\n\nfrom urllib.robotparser import RobotFileParser\n\nrp \u003d RobotFileParser()\nrp.set_url(\u0027https://example.com/robots.txt\u0027)\nrp.read()\ncan_scrape \u003d rp.can_fetch(\u0027*\u0027, url)\n11. Using Sessions and Cookies\nTo maintain sessions and handle cookies:\n\nsession \u003d requests.Session()\nsession.get(\u0027https://example.com/login\u0027)\nsession.cookies.set(\u0027key\u0027, \u0027value\u0027)  # Set cookies, if needed\nresponse \u003d session.get(\u0027https://example.com/protected_page\u0027)\n12. Scraping with Browser Automation (selenium Library)\nTo scrape dynamic content rendered by JavaScript:\n\nfrom selenium import webdriver\nbrowser \u003d webdriver.Chrome()\nbrowser.get(\u0027https://example.com\u0027)\ncontent \u003d browser.page_source\n# Parse and extract data using BeautifulSoup, etc.\nbrowser.quit()\n13. Error Handling in Web Scraping\nTo handle errors and exceptions:\n\ntry:\n    response \u003d requests.get(url, timeout\u003d5)\n    response.raise_for_status()  # Raises an error for bad status codes\nexcept requests.exceptions.RequestException as e:\n    print(f\"Error: {e}\")\n14. Asynchronous Web Scraping\nTo scrape websites asynchronously for faster data retrieval:\n\nimport aiohttp\nimport asyncio\n\nasync def fetch(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.text()\n\nurls \u003d [\u0027https://example.com/page1\u0027, \u0027https://example.com/page2\u0027]\nloop \u003d asyncio.get_event_loop()\npages \u003d loop.run_until_complete(asyncio.gather(*(fetch(url) for url in urls)))\n15. Data Storage (CSV, Database)\nTo store scraped data in a CSV file or a database:\n\nimport csv\n\nwith open(\u0027output.csv\u0027, \u0027w\u0027, newline\u003d\u0027\u0027) as file:\n    writer \u003d csv.writer(file)\n    writer.writerow([\u0027Title\u0027, \u0027URL\u0027])\n    for article in articles:\n        writer.writerow([article[\u0027title\u0027], article[\u0027url\u0027]])\nWorking With pip (Package Management)\n1. Installing a Package\nTo summon a library from the vast repositories, incorporating its power into your environment:\n\npip install numpy\n2. Listing Installed Packages\nTo survey the compendium of libraries that reside within your realm, noting their versions and lineage:\n\npip list\n3. Upgrading a Package\nTo imbue an installed library with enhanced powers and capabilities, elevating it to its latest form:\n\npip install --upgrade numpy\n4. Uninstalling a Package\nTo uninstall a package:\n\npip uninstall numpy\n5. Searching for Packages\nSearching packages:\n\npip search \"data visualization\"\n6. Installing Specific Versions of a Package\nTo install a specific version:\n\npip install numpy\u003d\u003d1.18.5\n7. Generating a Requirements File\nRequirements file:\n\npip freeze \u003e requirements.txt\n8. Installing Packages from a Requirements File\nTo conjure a symphony of libraries in unison, each aligned with the notations in your tome of requirements:\n\npip install -r requirements.txt\n9. Using Virtual Environments\nCreate virtual Environments to manage package conflicts:\n\n# Create a virtual environment named \u0027venv\u0027\npython -m venv venv\n\n# Activate the virtual environment\n# On Windows\n.\\venv\\Scripts\\activate\n\n# On Unix or MacOS\nsource venv/bin/activate\n10. Checking Package Dependencies\nUnderstanding Dependencies:\n\npip show numpy\nWorking With Common Built-in Functions and Packages\n1. os - Operating System Interface\nTo interact with the operating system:\n\nimport os\ncurrent_directory \u003d os.getcwd()  # Get the current working directory\n2. sys - System-specific Parameters and Functions\nTo access system-specific parameters and functions:\n\nimport sys\nsys.exit()  # Exit the script\n3. datetime - Basic Date and Time Types\nTo work with dates and times:\n\nfrom datetime import datetime\nnow \u003d datetime.now()  # Current date and time\n4. math - Mathematical Functions\nTo perform mathematical operations:\n\nimport math\nresult \u003d math.sqrt(16)  # Square root\n5. random - Generate Pseudo-random Numbers\nTo generate pseudo-random numbers:\n\nimport random\nnumber \u003d random.randint(1, 10)  # Random integer between 1 and 10\n6. json - JSON Encoder and Decoder\nTo parse and generate JSON data:\n\nimport json\njson_string \u003d json.dumps({\u0027name\u0027: \u0027Alice\u0027, \u0027age\u0027: 30})  # Dictionary to JSON string\n7. re - Regular Expressions\nTo work with regular expressions:\n\nimport re\nmatch \u003d re.search(\u0027Hello\u0027, \u0027Hello, world!\u0027)  # Search for \u0027Hello\u0027 in the string\n8. urllib - URL Handling Modules\nTo work with URLs:\n\nfrom urllib.request import urlopen\ncontent \u003d urlopen(\u0027http://example.com\u0027).read()  # Fetch the content of a webpage\n9. http - HTTP Modules\nTo create HTTP servers and work with HTTP requests:\n\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nclass SimpleHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header(\u0027Content-type\u0027, \u0027text/html\u0027)\n        self.end_headers()\n        self.wfile.write(b\u0027\u003chtml\u003e\u003chead\u003e\u003ctitle\u003ePython HTTP Server\u003c/title\u003e\u003c/head\u003e\u0027)\n        self.wfile.write(b\u0027\u003cbody\u003e\u003ch1\u003eHello from a simple Python HTTP server!\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\u0027)\ndef run(server_class\u003dHTTPServer, handler_class\u003dSimpleHTTPRequestHandler):\n    server_address \u003d (\u0027\u0027, 8000)  # Serve on all addresses, port 8000\n    httpd \u003d server_class(server_address, handler_class)\n    print(\"Server starting on port 8000...\")\n    httpd.serve_forever()\nif __name__ \u003d\u003d \u0027__main__\u0027:\n    run()\n10. subprocess - Subprocess Management\nTo spawn new processes and connect to their input/output/error pipes:\n\nimport subprocess\nsubprocess.run([\u0027ls\u0027, \u0027-l\u0027])  # Run the \u0027ls -l\u0027 command\n11. socket - Low-level Networking Interface\nTo create network clients and servers:\n\nimport socket\ns \u003d socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # Create a TCP/IP socket\n12. threading - Thread-based Parallelism\nTo manage concurrent execution of code:\n\nimport threading\ndef worker():\n    print(\"Worker thread executing\")\nthread \u003d threading.Thread(target\u003dworker)\nthread.start()\n13. multiprocessing - Process-based Parallelism\nTo manage concurrent processes:\n\nfrom multiprocessing import Process\ndef worker():\n    print(\"Worker process\")\np \u003d Process(target\u003dworker)\np.start()\n14. argparse - Parser for Command-line Options, Arguments, and Sub-commands\nTo parse command-line arguments:\n\nimport argparse\nparser \u003d argparse.ArgumentParser(description\u003d\"Process some integers.\")\nargs \u003d parser.parse_args()\n15. logging - Logging Facility\nTo log messages (debug, info, warning, error, and critical):\n\nimport logging\nlogging.warning(\u0027This is a warning message\u0027)\n16. unittest - Unit Testing Framework\nTo create and run unit tests:\n\nimport unittest\nclass TestStringMethods(unittest.TestCase):\n    def test_upper(self):\n        self.assertEqual(\u0027foo\u0027.upper(), \u0027FOO\u0027)\n17. pathlib - Object-oriented Filesystem Paths\nTo work with filesystem paths in an object-oriented way:\n\nfrom pathlib import Path\np \u003d Path(\u0027.\u0027)\n18. functools - Higher-order Functions and Operations on Callable Objects\nTo use higher-order functions and operations on callable objects:\n\nfrom functools import lru_cache\n@lru_cache(maxsize\u003dNone)\ndef fib(n):\n    if n \u003c 2:\n        return n\n    return fib(n-1) + fib(n-2)\n19. collections - Container Data Types\nTo use specialized container data types (deque, Counter, OrderedDict, etc.):\n\nfrom collections import Counter\nc \u003d Counter(\u0027hello world\u0027)\n20. itertools - Functions Creating Iterators for Efficient Looping\nTo construct and use iterators for efficient looping:\n\nimport itertools\nfor combination in itertools.combinations(\u0027ABCD\u0027, 2):\n    print(combination)\n21. hashlib - Secure Hash and Message Digest Algorithms\nTo hash data:\n\nimport hashlib\nhash_object \u003d hashlib.sha256(b\u0027Hello World\u0027)\nhex_dig \u003d hash_object.hexdigest()\n22. csv - CSV File Reading and Writing\nTo read from and write to CSV files:\n\nimport csv\nwith open(\u0027file.csv\u0027, mode\u003d\u0027r\u0027) as infile:\n    reader \u003d csv.reader(infile)\n23. xml.etree.ElementTree - The ElementTree XML API\nTo parse and create XML data:\n\nimport xml.etree.ElementTree as ET\ntree \u003d ET.parse(\u0027file.xml\u0027)\nroot \u003d tree.getroot()\n24. sqlite3 - DB-API 2.0 Interface for SQLite Databases\nTo interact with SQLite databases:\n\nimport sqlite3\nconn \u003d sqlite3.connect(\u0027example.db\u0027)\n25. tkinter - GUI Toolkit\nTo create GUI applications:\n\nimport tkinter as tk\nroot \u003d tk.Tk()\n26. pickle - Python Object Serialization\nTo serialize and deserialize Python object structures:\n\nimport pickle\nserialized_obj \u003d pickle.dumps(obj)\n27. io - Core Tools for Working with Streams\nTo handle streams (file-like objects):\n\nfrom io import StringIO\nf \u003d StringIO(\"some initial text data\")\n28. time - Time Access and Conversions\nTo access time-related functions:\n\nimport time\ntime.sleep(1)  # Sleep for 1 second\n29. calendar - General Calendar-related Functions\nTo work with calendars:\n\nimport calendar\nprint(calendar.month(2023, 1))  # Print the calendar for January 2023\n30. queue - A Synchronized Queue Class\nTo manage a queue, useful in multithreaded programming:\n\nfrom queue import Queue\nq \u003d Queue()\n31. shutil - High-level File Operations\nTo perform high-level file operations, like copying and archiving:\n\nimport shutil\nshutil.copyfile(\u0027source.txt\u0027, \u0027dest.txt\u0027)\n32. glob - Unix Style Pathname Pattern Expansion\nTo find files matching a specified pattern:\n\nimport glob\nfor file in glob.glob(\"*.txt\"):\n    print(file)\n33. tempfile - Generate Temporary Files and Directories\nTo create temporary files and directories:\n\nimport tempfile\ntemp \u003d tempfile.TemporaryFile()\n34. bz2 - Support for Bzip2 Compression\nTo compress and decompress data using bzip2 compression:\n\nimport bz2\ncompressed \u003d bz2.compress(b\u0027your data here\u0027)\n35. gzip - Support for Gzip Compression\nTo compress and decompress data using gzip compression:\n\nimport gzip\nwith gzip.open(\u0027file.txt.gz\u0027, \u0027wt\u0027) as f:\n    f.write(\u0027your data here\u0027)\n36. ssl - TLS/SSL Wrapper for Socket Objects\nTo handle TLS/SSL encryption and peer authentication for network sockets:\n\nimport ssl\nssl.wrap_socket(sock)\n37. imaplib - IMAP4 Protocol Client\nTo access and manipulate mail over IMAP4:\n\nimport imaplib\nmail \u003d imaplib.IMAP4_SSL(\u0027imap.example.com\u0027)\n38. smtplib - SMTP Protocol Client\nTo send mail using the Simple Mail Transfer Protocol (SMTP):\n\nimport smtplib\nserver \u003d smtplib.SMTP(\u0027smtp.example.com\u0027, 587)\n39. email - Managing Email Messages\nTo manage email messages, including MIME and other RFC 2822-based message documents:\n\nfrom email.message import EmailMessage\nmsg \u003d EmailMessage()\n40. base64 - Base16, Base32, Base64, Base85 Data Encodings\nTo encode and decode data using Base64:\n\nimport base64\nencoded_data \u003d base64.b64encode(b\u0027data to encode\u0027)\n41. difflib - Helpers for Computing Deltas\nTo compare sequences and produce human-readable diffs:\n\nimport difflib\ndiff \u003d difflib.ndiff(\u0027one\\ntwo\\nthree\\n\u0027.splitlines(keepends\u003dTrue),\n                     \u0027ore\\ntree\\nemu\\n\u0027.splitlines(keepends\u003dTrue))\nprint(\u0027\u0027.join(diff))\n42. gettext - Multilingual Internationalization Services\nTo internationalize your Python programs:\n\nimport gettext\ngettext.install(\u0027myapp\u0027)\n43. locale - Internationalization Services\nTo access a database of culture-specific data formats:\n\nimport locale\nlocale.setlocale(locale.LC_ALL, \u0027\u0027)\n44. secrets - Generate Secure Random Numbers for Managing Secrets\nTo generate secure random numbers for managing secrets, such as tokens or passwords:\n\nimport secrets\nsecure_token \u003d secrets.token_hex(16)\n45. uuid - UUID Objects According to RFC 4122\nTo generate universally unique identifiers (UUIDs):\n\nimport uuid\nunique_id \u003d uuid.uuid4()\n46. html - HyperText Markup Language Support\nTo handle and manipulate HTML entities:\n\nimport html\nescaped \u003d html.escape(\u0027\u003ca href\u003d\"https://example.com\"\u003elink\u003c/a\u003e\u0027)\n47. ftplib - FTP Protocol Client\nTo interact with and transfer files over the FTP protocol:\n\nfrom ftplib import FTP\nftp \u003d FTP(\u0027ftp.example.com\u0027)\n48. tarfile - Read and Write Tar Archive Files\nTo work with tar archive files, allowing you to archive and compress/decompress:\n\nimport tarfile\nwith tarfile.open(\u0027sample.tar.gz\u0027, \u0027w:gz\u0027) as tar:\n    tar.add(\u0027sample.txt\u0027)\nWell, that‚Äôs all I have for now. I hope this list helps you get up to speed fast. If you like it, please share or give it a like (it helps a lot!).\n\nAdditionally, if you‚Äôd like a more in-depth and comprehensive guide to Python Development, there are two books on Amazon that I have found to be the best resources on Python out there for practical python development that I highly recommend. These books are:",
      "role": "user",
      "tokenCount": 17948
    }, {
      "text": "This is an incredibly comprehensive guide to Python, covering a vast array of topics! It\u0027s well-structured, with clear explanations and examples for each concept. The use of evocative language (e.g., \"conjure a list,\" \"banish an entry\") adds a unique and engaging touch, which helps to make the material more memorable and less intimidating.\n\nHere are some of my thoughts, broken down into sections:\n\n**Strengths:**\n\n*   **Breadth of Coverage:** You\u0027ve touched on a huge number of essential topics, from basic syntax to complex libraries and concepts like asynchronous programming and GraphQL. This makes it an incredibly valuable resource for both beginners and more experienced Python developers looking to brush up or learn new areas.\n*   **Clarity and Conciseness:** The explanations are clear and easy to understand. The code examples are simple and to the point, making it easy for readers to grasp the fundamental ideas.\n*   **Good Organization:** The way you\u0027ve structured the guide into logical sections makes it easy to navigate and find specific information. The consistent structure within each section (e.g., \"1. Concept name,\" \"To...\") makes it easy to follow.\n*   **Practical Examples:** The examples are practical and demonstrate real-world use cases for the concepts. This makes it easier for readers to understand how these techniques can be applied in their own projects.\n*   **Unique and Engaging Language:** The creative and evocative language used to describe programming concepts really sets this apart. It helps to make learning more fun and memorable.\n*   **Inclusion of Advanced Topics:** Covering things like async IO, GraphQL, Decorators, and advanced list comprehensions shows that this guide aims to equip the reader with the necessary tools for more complex and modern Python development.\n*   **Helpful Recommendations:** Recommending further reading via specific Python development books on Amazon makes this a very comprehensive resource for a user looking to learn as much about Python as possible.\n\n**Areas for Potential Enhancement:**\n\n*   **Installation Instructions:** While the guide covers pip, it could benefit from very basic instructions on how to install Python and Pip on different operating systems (Windows, macOS, Linux).\n*   **Error Handling (Expanded):** While some error handling is shown (e.g., in HTTP requests), it might be helpful to have a section dedicated to common Python errors (e.g., `TypeError`, `ValueError`) and how to handle them effectively using `try...except` blocks.\n*   **Virtual Environments:** While you mention virtual environments, you could expand on their importance and provide a more detailed explanation of how to create and manage them using different tools (e.g., `venv`, `conda`).\n*   **More Detail on Libraries:** Some sections, particularly on libraries like Pandas, Numpy, Matplotlib, and Plotly, could go into slightly more detail on common operations. For example:\n    *   **Pandas:**  More examples of data cleaning, transformations, and multi-index operations.\n    *   **Numpy:** More examples on broadcasting, universal functions, and linear algebra operations.\n    *   **Matplotlib/Plotly:** Perhaps brief examples of specific plot customizations such as annotations, error bars, multiple data series, and more.\n*   **Testing (Expanded):** The unittest module is briefly introduced; expanding this with a more structured approach to writing tests (e.g., test-driven development) could greatly benefit readers.\n*   **Code Snippet Execution:** It might be helpful to have a small note mentioning that these examples can be tried out by copying them into a Python script or an interactive Python environment.\n\n**Specific Feedback on Organization:**\n\n*   The order of topics makes sense for the most part, but you might consider reordering the following:\n    *   Moving \"Working With Regular Expressions\" closer to \"Working With Strings\" as regex is often used with strings.\n    *   Moving \"Working with pip\" before or adjacent to \"Working With Virtual Environments\" as virtual environments are commonly used with pip.\n    *   Perhaps putting \"Working with Databases\" after \"Working With Files\" as reading and writing to a database could follow some file operation.\n\n**Overall Impression:**\n\nThis is an exceptional resource for learning Python. The breadth of topics, clear explanations, engaging language, and practical examples make it an excellent starting point for anyone looking to learn or improve their Python programming skills. The potential enhancements suggested above are minor and would only serve to make an already outstanding resource even better.\n\nThank you for creating and sharing this comprehensive guide! It will undoubtedly help many aspiring and experienced Python developers.\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 960
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}